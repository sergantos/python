#!/usr/bin/env python

print ("Hello world!")


''' ---------------------------------------
    Переменные
''' ---------------------------------------

#   Имя переменной должно начинаться с буквы или символа подчеркивания.
#   Оно не может начинаться с числа.
#   Имя переменной может содержать только буквенно-цифровые символы и символы подчеркивания (Az, 0-9 и _)
#   Имена переменных чувствительны к регистру (age, Age и AGE — три разных переменные)
#   Строки - это обычный массив символов

x = int(10) # x=10 class int
y = float(1.4) # y=1.4 class float
z = str("Привет Мир!") # z="3" class string
x, y, z = 10, 1.4, "Привет Мир!"
print(type(x))  # <class 'int'> - проверить тип переменной: int, float, complex
print(z[2:5]) # "иве" - Вывод части строки
print(z[0:6:2]) # "Пие" - c 0 символа до 6 шестого с шагом 2
print(z[::-1]) # Перевернуть строку
print("Привет Мир!"[1:-1] # Убрать первый и последний символ "ривет Мир"
print(z.strip()) # удаляет любые пробелы с начала или конца строки
print(z.lstrip()) # обрезает пробелы слева
print(z.rstrip()) # обрезает пробелы справа
print(len(z)) # длина строки
print(z.lower()) # строка в нижнем регистре
print(z.upper()) # строка в верхнем регистре
print(z.capitalize()) # Первая буква в верхнем регистре, остальные в нижнем
print(z.title()) # Первые буквы всех слов большие, остальные маленькие
print(z.swapcase()) # Заменить регистр на противоположный
print(z.count("Мир")) # Подсчитывает кол-во вхождений слова "Мир"
print(z.count("Мир", 0, 6)) # Подсчитывает кол-во вхождений слова "Мир" c 0 по 6 символ
print(z.endswith(".exe")) # Вернет true если строка заканчивается на .exe
print(z.find("Мир")) # Возвращает индекс символа где найдено совпадение, если ничего не найдено будет -1
print(z.rfind("Мир")) # Аналог find, но поиск начинается с конца строки
print(z.index("Мир")) # Возвращает индекс символа где найдено совпадение, если ничего не найдено будет ошибка
print(z.rindex("Мир")) # Аналог index, но поиск начинается с конца строки
print(z.replace("Ми","Мэ")) # Замена части строки - "Привет Мэр!"
zz=z.partition(" ") # Разбивает строку по разделителю, возвращает кортеж
zz=z.partition(" ") # Разбивает строку по разделителю, начиная справа, возвращает кортеж
zz=z.split(" ") # Разбивает строку по разделителю, возвращает список
zz=z.rsplit(" ") # Разбивает строку по разделителю, начиная справа, возвращает список
    z=";"
    zz=z.join(months) # Из списка/массива в строку. Обратное действие split
print(z*5) # Повторить строку 5 раз
print(chr(33)) # возвращает символ с кодом 33 т.е. !
print(ord("!")) # возвращает код символа "!" т.е. 33
print(str(33)) # выводит строку "33"
print(z.isalnum()) # true - если строка состоит только из букв и цифр
print(z.isalpha()) # true - если строка состоит только из букв
print(z.isdigit()) # true - если строка состоит только из цифр
z.isidentifier() # true - если строка является допустимым идентификатором
z.iskeyword() # true - если строка является ключевым словом в Python
z.islower() # true - если все буквы в нижнем регистре
z.isprintable() # true - если все символы печатаемые
z.isspace() # true - если строка только из пробельных символов т.е " ", \t, \n
z.istitle()
z.isupper()
print(z.center(10)) # выравнивание по центру
print(z.center(10,"-")) # выравнивание по центру c заполнением символами "-"
print(z.ljust(10)) # выравнивание по левому краю
print(z.ljust(10, "-")) # выравнивание по левому краю с заполнением символами "-"
print(z.rjust(10)) # выравнивание по правому краю
print(z.rjust(10, "-")) # выравнивание по правому краю с заполнением символами "-"
z.zfill(3) # заполняет строку слева 3 нулями
z.expandtabs() # Заменяет табуляцию на 8 пробелов

s = "Ты должен\tзаменить\nвсе символы переноса\bна пробелы"
remove_map = {
    ord('\n') : " ",    # \n перенос строки
    ord('\t') : " ",    # \t табуляция
    ord('\b') : " " }	# \b один символ назад
print(s.translate(remove_map))

MyNum = 42000.345
print(f'<MyNum is {MyNum}>')    # <MyNum is 42000.345> - Простой вывод значения переменной
print(f'<{MyNum=}>')    # <MyNum=42000.345> - Вывод Наименования переменной и через = вывод значения переменной
print(f'<{MyNum:12}>')   # <   42000.345> - Вывод числа прижать вправо до 12 знака, недостающие знаки заполнить пробелами
print(f'<{MyNum:_>12}>') # <___42000.345> - Вывод числа прижать вправо до 12 знака, недостающие знаки заполнить символом _
print(f'<{MyNum:0>12}>') # <00042000.345> - Вывод числа прижать вправо до 12 знака, недостающие знаки заполнить нулями
print(f'<{MyNum:<12}>')  # <42000.345   > - Вывод числа прижать влево до 12 знака, недостающие знаки заполнить пробелами
print(f'<{MyNum:_<12}>') # <42000.345___> - Вывод числа прижать влево до 12 знака, недостающие знаки заполнить символом _
print(f'<{MyNum:0<12}>') # <42000.345000> - Вывод числа прижать влево до 12 знака, недостающие знаки заполнить нулями
print(f'<{MyNum:.7f}>') # <42000.3450000> - Вывод числа с 7 знаками дробной части
print(f'<{MyNum:.1f}%>')    # <42000.3%> - Вывод числа с округлением до 1 знаками. Округление по математическим правилам т.е. после 5 увеличивается на 1
print(f'<{MyNum:,}>')    # <42,000.345> - Вывод числа с запятой для разделения тысяч

MyNow = datetime.datetime.now()
print(f'<{MyNow}>') # <2022-08-02 13:49:02.964491>
print(f'<Сегодня = {MyNow:%m-%d-%Y}>')  # <Сегодня = 08-02-2022>

year, month, day=2022,8,5
print(f'<{year}-{month:0>2}-{day:0>2}>')    # <2022-08-05>

# Время между двумя датами
import datetime
now = datetime.datetime.today()
NY = datetime.datetime(2024, 1, 1)
d = NY - now
mm, ss = divmod(d.second, 60)
hh, mm = divmod(mm, 60)
print('До нового года осталось: {} дней {} часов {} мин {} сек.'.format(d.days, hh, mm, ss)) # До нового года осталось: 362 дней 12 часов 6 мин 13 сек.


# !!! Внимание !!! работает только на Python 3.6 и выше
n=10
m=5
print(f'Произведение {n} на {m} равно {n*m}')
    \n  Новая строка
    \r  Возврат каретки
    \v или же \x0b  Таблицы строка
    \f или же \x0c	Подача формы
    \x1c	Разделитель файлов
    \x1d	Разделитель групп
    \x1e	Разделитель записей
    \x85	Следующая строка
    \u2028	Новая строка (Unicode)
    \u2029	Новый абзац (Unicode)

# Поменять значения местами
n, m = m, n

# Срезы или слайсы
x = [10, 5, 13, 4, 12, 43, 7, 8]
print( x[1:6:2]) # [5, 4, 43] - сделали срез с 1 элемента до 6 с шагом 2

# Приватные переменные - это те переменные, которые видны и доступны только в пределах класса, которому они принадлежат
# Для их объявления достаточно в начале имени переменной дописать два символа подчеркивания __
class Mainclass:
    __private_variable = 2021;
    def __private_method(self):
        print("Это вызов приватного метода")
    def insideclass(self):
        print("Это приватная переменная:", Mainclass.__private_variable)
        self.__private_method()
foo = Mainclass() 
foo.insideclass()   # Это приватная переменная: 2021
                    # Это вызов приватного метода
foo.__private_method() # ОШИБКА AttributeError!!! Приватный метод так нельзя вызвать !!!


# Процесс превращения переменных или методов в локальные называется «искажением данных» или «искажением имен» (data/name mangling). Он используется для избежания неоднозначности при определении имен подклассов.
# Настоящая приватность в Python не поддерживается, а ту, что есть, называют «слабым индикатором внутреннего использования». Для нее есть один символ нижнего подчеркивания (_), который используется для объявления приватных переменных, методов, функций и классов в модуле.
class Vehicle:
    def _start_engine(self):
        return "Создаем мотоцикл."
    def run(self):
        return self._start_engine()

if __name__ == '__main__':
    bike = Vehicle()
    print(bike._start_engine()) # Создаем мотоцикл.
    print("Мотоцикл создан.") # Мотоцикл создан.
    bike.run() # Ничего не выводится!
    print("Мотоцикл запущен.") # Мотоцикл запущен.


# Точность переменных с плавающей запятой
print(format(0.1, '.17f')) # 0.10000000000000001

# Тип данных Decimal обеспечивает большую точность
from decimal import Decimal
print(Decimal(1)/Decimal(3)) # 0.3333333333333333333333333333
print(Decimal(1)/Decimal(3)*Decimal(3) == Decimal(1)) # False <- но даже он не обеспечивает иногда требуемую точность

# Тип данных Fraction представляет и хранит число в виде рациональной дроби
from fractions import Fraction
print(Fraction(1)/Fraction(3)*Fraction(3) == Fraction(1)) # True <- правильная работа!!!


# Выводить символы Unicode (обязательно использовать префикс f)
print(f'Выводим символ \N{EM DASH} в Unicode') # Выводим символ — в Unicode
print(f'Выводим символ \u2014 в Unicode') # Выводим символ — в Unicode

# Присвоение переменной способом Walrus - сразу присваивает и сразу же его возвращает
a = [1, 2, 3]
if (n:= len(a)) > 2:
	print(f'Hi {n}') # Hi 3

# Параметры *args и **kwargs
*args	используется когда неизвестно, сколько именно аргументов будет принимать функция. В args запишется кортеж всех переданных значений
**kwargs	поступает почти также с именноваными аргументами
def func(*args):
	return args
print(func(1, 3, 2, 5, 4))	# (1, 3, 2, 5, 4)
def func2(**kwargs):
	return kwargs
print(func2(a=1, b=2, c=3))	# {'a': 1, 'b': 2, 'c': 3}


''' ---------------------------------------
    Работа с арифметикой
''' ---------------------------------------
    + добавление
    - вычитание
    * умножение
    / деление
    % остаток от деления
    ** возведение в степень
    // целочисленное деление
    
    x+=3 # увеличить значение на +3
    x&=3 # оператор x AND 3
    x|=3 # оператор x OR 3
    x^=3 # оператор x XOR 3
    x>>=3 # Сдвиг вправо на 3 бита
    x<<=3 # Сдвиг влево на 3 бита
    x=~x # инвертировать все биты
    
    == равно
    != не равно
    > больше
    < меньше
    >= больше или равно
    <= меньше или равно
    and
    or
    not
    is возвращает true если переменные один объект
    is not
    in возвращает true если переменная присутствует в объекте
    not in 

''' ---------------------------------------
    СПИСОК [list]
''' ---------------------------------------

# Список из названий месяцев
months = ['янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт','ноя', 'дек'] # список месяцев
months = list(('янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт','ноя', 'дек')) # другой способ - обрати внимание на двойные скобки!
print(months) # ['янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек']

a1 = months.copy() # сделаем копию массива
print(a1) # ['янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек']

print(len(months)) # 12 - Длина списка
print (months[0]) # янв - первый элемента массива начинается с 0
print (months[8]) # сен
print(max(months)) # 'янв' Выдает максимальное значение из списка. Если список из текста - то последний упорядоченный по алфавиту элемент
print(min(months)) # 'авг' Выдает минимальное значение из списка. Если список из текста - то первый упорядоченный по алфавиту элемент

months.append("13месяц") # Добавим в конец списка еще один элемент
print(months) # ['янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек', '13месяц']

months.insert(3,'3индекс') # вставим в позицию 3 списка новый элемент со значением "3индекс"
print(months) # ['янв', 'фев', 'март', '3индекс', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек', '13месяц']

months.pop(1) # удалим элемент с индексом 1 т.е. "фев"
print(months) # ['янв', 'март', '3индекс', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек', '13месяц']

months.remove('март') # удалим первый найденный элемент равный 'март'
print(months) # ['янв', '3индекс', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек', '13месяц']

months.extend(a1) # добавим к концу списка еще один список
print(months) # ['янв', '3индекс', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек', '13месяц', 'янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт', 'ноя', 'дек']

print(months.index('янв')) # 0 - возвращает индекс первого встреченного элемента с указанным значением

print(months.count('янв')) # 2 - Возвращает количество элементов с таким значением

months.reverse() # инвертируем список
print(months) # ['дек', 'ноя', 'окт', 'сен', 'авг', 'июль', 'июнь', 'май', 'апр', 'март', 'фев', 'янв', '13месяц', 'дек', 'ноя', 'окт', 'сен', 'авг', 'июль', 'июнь', 'май', 'апр', '3индекс', 'янв']

months.sort() # отсортируем список
print(months) # ['13месяц', '3индекс', 'авг', 'авг', 'апр', 'апр', 'дек', 'дек', 'июль', 'июль', 'июнь', 'июнь', 'май', 'май', 'март', 'ноя', 'ноя', 'окт', 'окт', 'сен', 'сен', 'фев', 'янв', 'янв']

months.clear() # очистим весь список
print("<", months, ">") # < [] >

# Удаление из списка дубликатов!!!
list_of_numbers = [22, 3,5,2,8,2,-23, 8,23,5] # Первоначальный список с дубликатами
list_of_numbers = list(dict.fromkeys(list_of_numbers)) # Итоговый список без дубликатов

# Разделение списка по отрезкам через разделитель 'o'
list_of_number = [ 1, 6, o, 2, 3, o, 4]
from itertools import groupby
b=[ list(group) for key, group in groupby( list_of_number, key=lambda x: x!=0 ) if key ]
	print(b) # [ [1, 6], [2, 3], [4]] ]

list_of_mine = [1, 2, 3, 4]
list2 = [6, 7]
list_of_mine = list_of_mine + [5] + list2 	# [[1, 2, 3, 4, 5, 6, 7]


''' ---------------------------------------
    КОРТЕЖ (tuple) - тоже самое что и список, но его НЕЛЬЗЯ изменять !!!
''' ---------------------------------------

months = ('янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт','ноя', 'дек') # Кортеж месяцев
months = tuple(('янв', 'фев', 'март', 'апр', 'май', 'июнь', 'июль', 'авг', 'сен', 'окт','ноя', 'дек'))

print(months.count('янв') # 1 - количество элементов с таким значением

print(month.index(2)) # март - возвращает значение 2 элемента

months.clear() # Очищаем кортеж



''' ---------------------------------------
    МНОЖЕСТВО {set} - тоже самое что и список, но неупорядоченный и не индексируемый
''' ---------------------------------------

months = {'янв', 'фев', 'март', 'апр', 'май'} # множество месяцев

months = set(('янв', 'фев', 'март', 'апр', 'май', 'янв', 'фев')) # другой способ
print(months) # {'май', 'апр', 'янв', 'фев', 'март'} - множество хранит ТОЛЬКО уникальные элементы

# получить доступ к элементам множества произвольно невозможно (не индексируемый), но можно перебрать их в цикле
for x in months:
    print(x) # янв фев март апр май

# Проверим, входят ли элементы в множество months
print('июнь' in months) # false
print('янв' in months) # true

# Добавим один элемент в множество
months.add('июнь')
print(months) # {'янв', 'март', 'апр', 'май', 'фев', 'июнь'}

# Добавим три элемента в множество
months.update(['июль', 'авг', 'сен'])
print(months) # {'авг', 'май', 'июль', 'фев', 'апр', 'сен', 'март', 'янв', 'июнь'} - обрати внимание: элементы НЕ упорядочены

# Получим длину множества
print(len(months)) # 9

# Удалим элемент из множества
months.remove('апр') 
months.remove('дек') # Такого элемента нет - выдается ошибка!!!
months.discard('янв')
months.discard('дек') # Такого элемента нет - но никакой ошибки
print(months) # {'сен', 'март', 'июль', 'фев', 'авг', 'май', 'июнь'}
print(months.pop()) # удаляет случайный элемент и возвращает его название, например 'март'

# Очистим множество
months.clear # очистит множество, но оставит запись о его наименовании в оперативке, т.е. можно будет добавлять элементы
del months # полностью удаляет с очищением памяти

# Дополнительные методы множества:
print(months.difference(a1)) # Возвращает множество элементов, которые есть в {months}, но их нет в {a1}
print(months.difference_update(a1)) # Удаляет элементы которые есть и в {months} и в {a1}
print(months.intersection(a1)) # Возвращает множество, являющееся пересечением {months} и {a1}
print(months.intersection_update(a1)) # Удаляет элементы в {months}, которых нет {a1}
months.isdisjoint(a1) # True, если {months} и {a1} не имеют общих элементов
months.issubset(a1) # True, если все элементы {months} есть в {a1}
months.issuperset(a1) # True, если все элементы из {a1} есть в {months}
months.symmetric_difference(a1) # 
months.symmetric_difference_update(a1) # 
months.union(a1) # ОБъединяет множества {months} и {a1}
months.update(a1,b2) # Объединяет множества {a1} и {b2} и перезаписывает {months}


''' ---------------------------------------
    СЛОВАРЬ {dict} - тоже самое что и список, но неупорядоченный, зато индексируемый
''' ---------------------------------------

months = {
    "01": "январь",
    "02": "февраль",
    "03": "март",
    "04": "апрель"
}
print (months) # {'01': 'январь', '02': 'февраль', '03': 'март', '04': 'апрель'}
print(months["01"]) # январь
print(months.get("01")) # январь
for x in months:
    print(x) # выведем один за другим все ключи "01","02","03","04"
for x in months:  
    print(months[x]) # выведем один за другим все значения "январь","февраль","март","апрель"
for x in months.values():
    print(x) # выведем один за другим все значения "январь","февраль","март","апрель"
for x, y in months.items():
    print(x, y) # выведем один за другим все ключи и значения "01" "январь", "02" "февраль","03" "март","04" "апрель"

# Создание словаря по набору ключей
keys = [ 'a', 'b', 'c' ]
res = {k: True for k in keys}
print(res) # {'a': True, 'b': True, 'c': True}
res1=dict.fromkeys(keys, True)
print(res1) # {'a': True, 'b': True, 'c': True}

# Сортировка словаря по ключам, а не по значениям
fruit = { 'яблоки': 80, 'апельсины': 40, 'бананы':70}
print( sorted(fruit, key=fruit.get) ) # ['апельсины', 'бананы', 'яблоки']

# Т.к. словари не могут иметь дубликатов - это можно использовать для создания списка без дубликатов!!!
list_of_numbers = [22, 3,5,2,8,2,-23, 8,23,5] # Первоначальный список с дубликатами
list_of_numbers = list(dict.fromkeys(list_of_numbers)) # Итоговый список без дубликатов

# Объединить словари с одинаковыми ключами без замены значений
users = [ ('Иван', 'Иванов'), ('Петр', 'Петров'), ('Сидор', 'Сидоров'), ('Роман','Романов') ]
outs = {'Пользователи': list(map(lambda u: {'Имя': u[0], 'Фамилия': u[1]}, users))} # 
print(outs) # {'Пользователи': [{'Имя': 'Иван', 'Фамилия': 'Иванов'}, {'Имя': 'Петр', 'Фамилия': 'Петров'}, {'Имя': 'Сидор', 'Фамилия': 'Сидоров'}, {'Имя': 'Роман', 'Фамилия': 'Романов'}]}



''' ---------------------------------------
    ИТЕРАТОР - работа с списками, кортежами, множествами, словарями при помощи итераторов
''' ---------------------------------------

# Итератор - указатель на элемент списка, который может сдвигаться
mytuple = ("яблоко", "банан", "вишня")
myit = iter(mytuple) # создали итератор
print(next(myit))
print(next(myit))
print(next(myit))

# Перебор списка итератором
months=['янв', 'фев', 'март', 'апр', 'май']
MyIt=iter(months) # создали итератор
for i in range(5):
    print(next(MyIt)) # перебираем в цикле все элементы массива

# Другой пример:
class MyNumbers:
    def __iter__(self): # Создадим конструктор класса
        self.a = 1
        return self
    
    def __next__(self): # Создадим команду next класса
        if self.a <= 20:  
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration # Если значения при итерации превысит 20 то останавливаем итерацию

myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
    print(x)

# Создать список содержащие только четные числа от 0 до 20
print([x for x in range(20) if x%2==0])


''' ---------------------------------------
    УСЛОВИЯ
''' ---------------------------------------

if a > b:
    print("a больше чем b")
elif a == b:
    print("a равно b")
else:
    print("b больше чем a")

if a > b: print("a больше, чем b")
print("A") if a > b else print("B")

if a > b and b > c:
    print("Оба условия True")  



''' ---------------------------------------
    ЦИКЛЫ
''' ---------------------------------------

ind=1
while ind < 6:
    print("Индекс", ind)
    if ind == 2:
        continue # если ind=2 то пропустить эту итерацию и сразу начать следующую т.е. ind=3
    ind+=1
    if ind == 3:
        break # прерывание цикла если ind=3
    
for i in "банан":
    print(i) # "б", "а", "н", "а", "н"

for i in range(6): # от 0 до 5
    print(i) # 0 1 2 3 4 5

for i in range(2,6): # от 2 до 5
    print(i) # 2 3 4 5

for i in range(2, 6, 3): # От 2 до 6 с шагом 3
    print(i) # 2 5

for i in range(2, 6, 3): # От 2 до 6 с шагом 3
    print(i) # 2 5
else: # Если цикл не выполнился то делай. Если цикл не завершен (например, из-за break) то код не выполнится
    print("Цикл вообще не запустился")

# Перебор элементов списка через enumerator
my_list = ['яблоко', 'тыква', 'банан', 'ананас']
for c, value in enumerate(my_list, 1):
    print(c, value) # 1 яблоко
					# 2 тыква
					# 3 банан
					# 4 ананас


''' ---------------------------------------
    ФУНКЦИИ
''' ---------------------------------------


def my_function():
    print("Выводим из функции")

def my_function1(my_arg):
    print("Вывод из функции аргумента ", my_arg)

def my_function2(my_arg="Передали пустой аргумент"):
    print("Вывод из функции аргумента ", my_arg)

def my_function3(ind):
    return ind**2

my_function() # вызов функции

x = lambda a, b: a* b2
print(x(5,6))


# Функция с значениями по-умолчанию
def func(a, b=4, c=7):
    print('a={}, b={}, c={}'.format(a, b, c))
func(3, 6)	# a=3, b=6, c=7
func(25, c=24)	# a=25, b=4, c=24
func(c=50, a=2)	# a=2, b=4, c=50


# Функция с бесконечными параметрами
def total(a=5, *number, **phone):
    ''' 
значение собранные в * будут собраны в кортеж, 
значения собранные ** будут собраны в словарь
	'''
	print('a={}'.format(a))
    # Проход по всем элементам кортежа
    for singleItem in number:
        print('Выбран элемент: {}'.format(singleItem))
    # Проход по всем элементам словаря
    for firstPart, secondPart in phone.items():
        print('1-я часть: {}, 2-я часть: {}'.format(firstPart, secondPart))
total(10, 12, 13, 14, serg='8-925-934-73-84', anna='8-917-923-08-10', semen='8-925-900-35-53')
print(total.__doc__)
#					a=10
#					Выбран элемент: 12
#					Выбран элемент: 13
#					Выбран элемент: 14
#					1-я часть: serg, 2-я часть: 8-925-934-73-84
#					1-я часть: anna, 2-я часть: 8-917-923-08-10
#					1-я часть: semen, 2-я часть: 8-925-900-35-53
#					значение собранные в * будут собраны в кортеж,
#					значения собранные ** будут собраны в словарь


# Сортировка с помощью lambda-функции:
a = [ (1,2), (4,1), (9,10), (13, -3) ]
a.sort(key=lambda x: x[1]) # Сортировка по 2-му элементу 
print(a) # [(13, -3), (4, 1), (1, 2), (9, 10)]


# Области видимости переменных в функции
def func(x):
    global y
    print('1) Вход в функцию: x={}, y={}'.format(x, y)) 	# 40, 50
    x = 30 
    y += 5
    print('2) Изменения переменных: x-локальная={}, y-глобальная={}'.format(x, y))	# 30, 55
x, y = 40, 50
func(x)
print('3) Выход из функции. х={}, y={}'.format(x, y))	# 40, 55


# Область видимости нелокольных переменных
def func_out():
    def func_inner():
        nonlocal x
        x = 5

    x = 2
    print('1) Вход в первую функцию: x={}'.format(x))	# 2
    func_inner()
    print('2) После встроенной функции: x={}'.format(x))	# 5
func_out()


# Бесконечное количество аргументов, передаваемых в функцию
def total(a=5, *number, **phone):
    ''' 
	значение собранные в * будут собраны в кортеж, 
	значения собранные ** будут собраны в словарь
    '''
    print('a={}'.format(a))	# a=10
    # Проход по всем элементам кортежа
    for singleItem in number:
        print('Выбран элемент: {}'.format(singleItem))	# Выбран элемент: 12 Выбран элемент: 13 Выбран элемент: 14
    # Проход по всем элементам словаря
    for firstPart, secondPart in phone.items():
        print('1-я часть: {}, 2-я часть: {}'.format(firstPart, secondPart))	# 1-я часть: serg, 2-я часть: 8-925-934-73-84	1-я часть: anna, 2-я часть: 8-917-923-08-10		1-я часть: serg, 2-я часть: 8-925-934-73-84

total(10,12, 13, 14, serg='8-925-934-73-84', anna='8-917-923-08-10', semen='8-925-900-35-53')
print(total.__doc__)	#  значение собранные в * будут собраны в кортеж, значения собранные ** будут собраны в словарь



# оператор return должен быть последним оператором в функции. Но можно использовать другой оператор yield - вернуть значение и продолжить выполнять функцию! Пример - вычисление функции Фибоначи
def fibonacci(xterms):
    # первые два условия
    x1 = 0
    x2 = 1
    count = 0

    if xterms <= 0:
        print("Укажите целое число больше 0")
    elif xterms == 1:
        print("Последовательность Фибоначчи до", xterms, ":")
        print(x1)
    else:
        while count < xterms:
            xth = x1 + x2
            x1 = x2
           x2 = xth
           count += 1
           yield xth
fib = fibonacci(5)
print(next(fib)) # 1
print(next(fib)) # 2
print(next(fib)) # 3
print(next(fib)) # 5
print(next(fib)) # 8
print(next(fib)) # StopIteration

# ГЕНЕРАТОРЫ
# генераторы полезны при обработке больших объемов данных. Например, нам надо раскидать 1 миллиард файлов в каталоге по дате/времени. Если попробуем сформировать такой список файлов и перебирать его в цикле - у нас будет ошибка: список из названий файлов съест всю доступную память и цикл не выполнится ни разу. Решение - использовать генератор! Генератор получит название 1-го файла и вернет нам для обработки. При последующем вызове генератора мы получим уже название 2-го файла, который снова обработаем и т.д. весь миллиард файла.

# Генерация арифметической прогрессии с помощью генератора
def AP(a1, d, size):
    count = 1
    while count <= size:
        yield a1
        a1 += d
        count += 1
for ele in AP(1, 2, 10):
    print(ele)

# Простые числа с помощью генератора
def find_prime():
    num = 1
    while True:
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
            else:
                yield num
        num += 1
for ele in find_prime():
    print(ele)

# простой пример генератора
def generator_function():
	for i in range(10):
		yield i
for item in generator_function():
	print(item)# 0 1 2 3 4 5 6 7 8 9


# Рекурсия функции - ограничение рекурсии по-умолчанию установлено 1000 циклов. Но это можно изменить
def recursing(depth):
    try:
        recursing(depth + 1)
    except RuntimeError as RE:
        print('Рекурсия выполнила {} циклов'.format(depth) )
recursing(0) # Рекурсия выполнила 985 циклов
import sys
sys.setrecursionlimit(2000)
recursing(0) # Рекурсия выполнила 1985 циклов


''' ---------------------------------------
    Классы и объекты
''' ---------------------------------------

class my_class:
    x=5
p1=my_class
print(p1.x) # 5


class persona:
    def __init__(self, fam, name, age): 
        self.fam = fam 
        self.name = name
        self.age = age
    def privet(abc):
        print("Привет, меня зовут", abc.name)
    def privet2(self):
        print("Моя фамилия", self.fam)

p1=persona("Лавров", "Василий", "50")
print(f'Создана персона {p1.fam} {p1.name}') # Создана персона Лавров Василий
p1.privet() # Привет, меня зовут  Василий
p1.privet2() # Моя фамилия Лавров
p1.age=40
print(p1.age) # 40
del p1.age # удалить свойство объекта
del p1 # удалить объект

# Наследуемые классы
class person:
    def __init__(self, name):
        self.name = name
    def get_name(self):
        return self.name
    def is_employ(self):
        return False
class employee(person):
    def is_employ(self):
        return True
john = person('Sergey')
print( john.get_name(), john.is_employ() ) # Sergey False
maria = employee('Инна')
print( maria.get_name(), maria.is_employ() ) # Инна True



''' ---------------------------------------
    МОДУЛИ
''' ---------------------------------------

# Для того, чтобы создать модуль достаточно просто сохранить код в файл с расширением .py (это важно!!!)

# Например, создаем файл module1.py
    def greeting(name):
        print("Привет, " + name)
# После используем его в другом проекте:
import module1
module1.greeting("Сергей") # Привет Сергей


# Переменные в модуле также становятся доступными в основной программе:
# module1.py:
person1 = {
"name": "Виктор",
"age": 36,
"country": "Россия"}
# Основная программа:
import module1
a = mymodule.person1["age"] 
print(a) # 36
# Другой способ обращаться к модулю:
import mymodule as mx
a = mx.person1["age"]
print(a) # 36


# В python несколько встроенных модулей

# Существует встроенная функция для перечисления всех имен функций (или имен переменных) в модуле. Функция dir()
import module1
x = dir(module1)
print(x) # ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'person1']

# Импорт из модулю частично
from module1 import person1
print(person1["age"])


''' ---------------------------------------
    Работа с временем
''' ---------------------------------------

# импортируем библиотеку для работы с временем
import datetime

dt1 = datetime.datetime(2000,12,31,10,20,40)
dt2 = datetime.datetime(2010,12,31,10,20,50)
dt3 = datetime.datetime.now() # текущая дата в формате 2021-12-03 19:33:55.494442
print(dt3.year) # год
print(dt3.month) # месяц
print(dt3.day) # день
print(dt3.hour) # час
print(dt3.minute) # минуты
print(dt3.second) # секунды
print(dt3.microsecond) # микросекунды
print(dt3.strftime("%A")) # день недели
    %a	День недели, короткий вариант	Wed
    %A	Будний день, полный вариант	Wednesday
    %w	День недели числом 0-6, 0 — воскресенье	3
    %d	День месяца 01-31	31
    %b	Название месяца, короткий вариант	Dec
    %B	Название месяца, полное название	December
    %m	Месяц числом 01-12	12
    %y	Год, короткий вариант, без века	18
    %Y	Год, полный вариант	2018
    %H	Час 00-23	17
    %I	Час 00-12	05
    %p	AM/PM	PM
    %M	Минута 00-59	41
    %S	Секунда 00-59	08
    %f	Микросекунда 000000-999999	548513
    %z	Разница UTC	+0100
    %Z	Часовой пояс	CST
    %j	День в году 001-366	365
    %U	Неделя числом в году, Воскресенье первый день недели, 00-53	52
    %W	Неделя числом в году, Понедельник первый день недели, 00-53	52
    %c	Локальная версия даты и времени	Mon Dec 31 17:41:00 2018
    %x	Локальная версия даты	12/31/18
    %X	Локальная версия времени	17:41:00
    %%	Символ “%”	%

# Зададим спецпеременную для разности дат
dt3 = datetime.timedelta
dt3 = dt2 - dt1
print("Количество дней между датами: ", dt3.days) # Количество дней между датами:  3652
print("Количество секунд между датами: ", dt3.seconds) # Количество секунд между датами:  10
print("Общее количество секунд с учетом дат: ", dt3.total_seconds()) # Общее количество секунд с учетом дат:  315532810.0

# Из даты вычесть время:
import datetime
from datetime import date
open = datetime.datetime.strptime(str(date.today()) + ' 10:00:00', '%Y-%m-%d %H:%M:%S') # datetime.datetime(2022, 4, 13, 10, 0)
now = datetime.datetime.today() # datetime.datetime(2022, 4, 13, 17, 30, 11, 826386)
trading_open = now - open # datetime.timedelta(seconds=27011, microseconds=826386)
print(trading_open) # 7:30:11.826386


''' ---------------------------------------
    JSON - текст, написанный по стандарту JavaScript
''' ---------------------------------------

# Подключаем модуль
import json

# Конвертация строки json в словарь
x = '{"name":"Viktor", "age":30, "city":"Minsk"}' # строка json
y = json.loads(x) # парсинг x:
print(y["age"]) # Результат - словарь Python

# Конвертация из Python в json
import json

# создаем словарь x:
x = {
"name": "Viktor",
"age": 30,
"city": "Minsk"
}
# конвертируем в JSON: 
y = json.dumps(x)
# в результате получаем строку JSON:
print(y)

# Конвертация объектов в json
    Python	    JSON
    dict	    Object
    list	    Array
    tuple	    Array
    str	        String
    int	        Number
    float	    Number
    True	    true
    False	    false
    None	    null

# Конвертация кириллицы
# Если в данных Python есть символы кириллицы, метод json.dumps() преобразует их с кодировкой по умолчанию. Что бы сохранить кириллицу используйте параметр ensure_ascii=False
import json
x = { "name": "Виктор" }
y = { "name": "Виктор" }
print(json.dumps(x)) # {"name": "\u0412\u0438\u043a\u0442\u043e\u0440"}
print(json.dumps(y, ensure_ascii=False)) # {"name": "Виктор"}

# Форматирование результата конвертации
json.dumps(x, indent=4, separators=(". ", " = ")) # При конвертации добавлять 4 отступа и выставить разделители вместо "," и ":" по-умолчанию на ". " и " = " для удобства чтения 

# Упорядочивание результата конвертации
json.dumps(x, indent=4, sort_keys=True)


''' ---------------------------------------
    Регулярные выражения
''' ---------------------------------------

import re
txt =  "The rain in Spain"
x = re.search("^The.*Spain$", txt)
x = re.search("^The.*Spain$", txt, flags=re.IGNORECASE) # поиск 

#   Функции	    Значение
    findall	    Возвращает список со всеми совпадениями
    search	    Возвращает объект Match, если в строке есть совпадение
    split	    Возвращает список, из строки, которую разделили по шаблону
    sub	        Заменяет совпадение по шаблону, на заданную строку

# Метасимволы
    []	Содержит символы для поиска вхождений, например [a-m]
    \	Сигнализирует о специальном символе (также может использоваться для экранирования специальных символов), например	\d
    .	Любой символ, кроме новой строки (\n), например "he…o"
    ^	Строка начинается с ..., например "^hello"
    $	Строка заканчивается ..., например "world$"
    *	0 и более вхождений, например "aix*"
    +	1 и более вхождений, например "aix+"
    {}	Указанное количество вхождений	"al{2}"
    |	Или, например "falls|stays"
    ()	Группирует шаблон

# Специальные пары символов
    Символ	    Значение	                    Пример
    \A	        Ищет символы в начале строки	“\AThe”
    \b	        Ищет символы в начале или конец слова, в зависимости от расположения	r»\bain» r»ain\b»
    \B	        Ищет символы которые находятся НЕ в начале или конце строки	r»\Bain» r»ain\B»
    \d	        Ищет совпадения с числами 0-9	“\d”
    \D	        Ищет совпадение, где строка не содержит числа	“\D”
    \s	        Ищет совпадение с символом пробела	“\s”
    \S	        Ищет совпадение, где строка НЕ содержит пробел	“\S”
    \w	        Ищет совпадение, где строка содержит буквы, цифры или символ по подчеркивания (_)	“\w”
    \W	        Ищет совпадение, где строка НЕ содержит буквы, цифры или символ по подчеркивания (_)	“\W”
    \Z	        Ищет символы в конце строки	“Spain\Z”
    \n          Ищет новую строку
    \t          Ищет табуляцию

# Комбинации символов
    Комбинации	Значение
    [arn]	    Возвращает совпадение, в котором присутствует один из указанных символов (a, r или n)
    [a-n]	    Возвращает совпадение для с символом нижнего регистра в алфавитном порядке между a и n, включая их
    [^arn]	    Возвращает совпадение для любого символа, КРОМЕ а, r и n
    [0123]	    Возвращает совпадение, в котором присутствует любая из указанных цифр (0, 1, 2 или 3)
    [0-9]	    Возвращает совпадение с любой цифрой от 0 до 9
    [0-5][0-9]	Возвращает совпадение с любыми двузначными числами от 0 до 59
    [a-zA-Z]	Возвращает совпадение с любым символом английского алфавита между a и z, включая строчные буквы и прописные
    [а-яА-ЯёЁ]	Возвращает совпадение с любым символом русского алфавита между а и я, включая строчные буквы и прописные
    [+]	        В комбинациях символы +, *, ., |, (), $,{} не имеют особенного значения, поэтому [+]: будет искать любой + в строке


# найти все совпадения
import re
string = "The rain in Spain"
x = re.findall("ai",  string)
print(x) # ['ai', 'ai']

# Найдем первый символ пробела в строке
import re
string = "The rain in Spain"
x = re.search("\s", string)
print("Индекс первого пробела:", x.start())

# Создадим список из строки
import re
string = "The rain in Spain"
x = re.split("\s", string)
print(x) # ['The', 'rain', 'in', 'Spain']

# Заменим каждый символ пробела цифрой 9
import re
string = "The rain in Spain"
x = re.sub("\s", "9", string)
print(x) # The9rain9in9Spain
x = re.sub("\s", "9", string, 2) # ограничим количество замен 2 штуками
print(x) # The9rain9in Spain

# Объект MATCH - объект, содержащий информацию о поиске. Если совпадений нет - будет None
# Выполним поиск, который вернет объект Match
import re
string =  "The rain in Spain"
x = re.search("ai", string)
print(x)  # <re.Match object; span=(5, 7), match='ai'>
print(x.span()) # возвращает кортеж, содержащий начальную и конечную позиции совпадения.
print(x.string) # возвращает строку, переданную в функцию.
print(x.group()) # возвращает часть строки, где было совпадение

# Выведем позицию (начальную и конечную) первого совпадения
import re
string = "The rain in Spain"
x = re.search(r"\bS\w+", string)
print(x.span()) # (12, 17)

# Выведем строку, переданную в функцию
import re
string = "The rain in Spain"  
x = re.search(r"\bS\w+", string)
print(x.string) # The rain in Spain

# Выведем часть строки, где было совпадение
import re
string = "The rain in Spain"
x = re.search(r"\bS\w+", string)  # Слово, которое начинается с S и продолжается буквенными символом
print(x.group()) # Spain



''' ---------------------------------------
    Скачивание новых библиотек с помощью менеджера пакетов PIP
''' ---------------------------------------

pip --version # номер версии
pip <название библиотеки>
pip install camelcase

 https://pypi.org/ # библиотеки для python

PS D:\python> pip --help

Usage:
  pip <command> [options]

Commands:
  install                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  check                       Verify installed packages have compatible dependencies.
  config                      Manage local and global configuration.
  search                      Search PyPI for packages.
  cache                       Inspect and manage pip's wheel cache.
  index                       Inspect information available from package indexes.
  wheel                       Build wheels from your requirements.
  hash                        Compute hashes of package archives.
  completion                  A helper command used for command completion.
  debug                       Show information useful for debugging.
  help                        Show help for commands.

General Options:
  -h, --help                  Show help.
  --debug                     Let unhandled exceptions propagate outside the main subroutine, instead of logging them to stderr.
  --isolated                  Run pip in an isolated mode, ignoring environment variables and user configuration.
  --require-virtualenv        Allow pip to only run in a virtual environment; exit with an error otherwise.
  -v, --verbose               Give more output. Option is additive, and can be used up to 3 times.
  -V, --version               Show version and exit.
  -q, --quiet                 Give less output. Option is additive, and can be used up to 3 times (corresponding to WARNING, ERROR, and CRITICAL logging levels).
  --log <path>                Path to a verbose appending log.
  --no-input                  Disable prompting for input.
  --proxy <proxy>             Specify a proxy in the form [user:passwd@]proxy.server:port.
  --retries <retries>         Maximum number of retries each connection should attempt (default 5 times).
  --timeout <sec>             Set the socket timeout (default 15 seconds).
  --exists-action <action>    Default action when a path already exists: (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.
  --trusted-host <hostname>   Mark this host or host:port pair as trusted, even though it does not have valid or any HTTPS.
  --cert <path>               Path to PEM-encoded CA certificate bundle. If provided, overrides the default. See 'SSL Certificate Verification' in pip documentation for more information.
  --client-cert <path>        Path to SSL client certificate, a single file containing the private key and the certificate in PEM format.
  --cache-dir <dir>           Store the cache data in <dir>.
  --no-cache-dir              Disable the cache.
  --disable-pip-version-check
                              Don't periodically check PyPI to determine whether a new version of pip is available for download. Implied with --no-index.
  --no-color                  Suppress colored output.
  --no-python-version-warning
                              Silence deprecation warnings for upcoming unsupported Pythons.
  --use-feature <feature>     Enable new functionality, that may be backward incompatible.
  --use-deprecated <feature>  Enable deprecated functionality, that will be removed in the future.



''' ---------------------------------------
    ОБРАБОТКА ИСКЛЮЧЕНИЙ
''' ---------------------------------------

try: 	# проверить блок кода на ошибку
    print(f'Переменная {X=}')
except NameError: # Возникла ошибка: NameError
    print('Вот в чем дело - переменная Х не существует!')
except:	# Общее исключение должно идти самым последним из всех других исключений
    print('Что-то пошло не так, но что именно - я не знаю')
else:	# Выполнить код если ошибки не возникло
    print('Ошибок нет! Все хорошо.')
finally:	# Выполняем код в любом случае, независимо от результата
    print('Блок проверки исключений завершен - выполнюсь в любом случае')



''' ---------------------------------------
    Инструкции и выражения
''' ---------------------------------------

test = "Изучение python"
print(id(test)) # 2040896942896 - выведем адрес памяти, где сохранена строка test



''' ---------------------------------------
    Встроенная функция FILTER
''' ---------------------------------------

# Функция применяет другую функцию к заданному итерируемому объекту (список, строка, словарь и так далее), проверяя, нужно ли сохранить конкретный элемент или нет\
# Ее синтаксис такой
list2 = filter(<my_function>,<my_list>) # Возвращает список
# Фактически она подменяет собой перебор элементов списка в цикле и формирует из них новый список
# Важно!!! Функция <my_function> должна возвращать или True или False иначе ничего не получится


# Пример # 1 использования - фильтр нечетных чисел
numbers = [1, 2, 4, 5, 7, 8, 10, 11] # список чисел
# функция, которая проверяет числа
def filter_odd_num(in_num):
    if(in_num % 2) == 0:
        return True
    else:
        return False
out_filter = filter(filter_odd_num, numbers) # Применение filter() для удаления нечетных чисел
print("Тип объекта out_filter: ", type(out_filter)) # Тип объекта out_filter:  <class 'filter'>
print("Отфильтрованный список: ", list(out_filter)) # Отфильтрованный список:  [2, 4, 8, 10]


# Пример № 2 использования - Разница двух массивов
# Список строк с похожими элементами
list1 = ["январь", "февраль", "март", "апрель", "май", "июнь"]
list2 = ["апрель", "май", "июнь", "июль", "август", "сентябрь"]
def filter_dublicate(string_to_check):
    if string_to_check in ll:
        return False
    else:
        return True
# Применение filter() для удаления повторяющихся строк
ll = list2
out_filter = list(filter(filter_dublicate, list1))
ll = list1
out_filter += list(filter(filter_dublicate, list2))
print("Разница двух списков:", out_filter) # Разница двух списков: ['январь', 'февраль', 'март', 'июль', 'август', 'сентябрь']


# Пример № 3 использования - Пересечение двух массивов
# Два массива, имеющие общие элементы
arr1 = ["январь", "февраль", "март", "апрель", "май", "июнь"]
arr2 = ["апрель", "май", "июнь", "июль", "август", "сентябрь"]
# Лямбда с использованием filter() для поиска общих значений
def interSection(arr1, arr2): # найдем общие элементы
   out = list(filter(lambda it: it in arr1, arr2))
   return out
# функция main
if __name__ == "__main__":
   out = interSection(arr1, arr2)
   print("Пересечение двух массивов:", out) # Пересечение двух массивов: ['апрель', 'май', 'июнь']


# Пример № 4 использования - Отфильтровать стоп-слова из строки
list_of_stop_words = ["в", "и", "по", "за"] # Список стоп-слов
string_to_process = "Сервис по поиску работы и сотрудников HeadHunter опубликовал подборку высокооплачиваемых вакансий в России за август." # Строка со стоп-словами
# lambda-функция, фильтрующая стоп-слова
split_str = string_to_process.split()
filtered_str = ' '.join((filter(lambda s: s not in list_of_stop_words, split_str)))
print("Отфильтрованная строка:", filtered_str) # Отфильтрованная строка: Сервис поиску работы сотрудников HeadHunter опубликовал подборку высокооплачиваемых вакансий России август.


# Пример № 5 использования - использование функции без аргументов, передаем None вместо имени функции
bools = ['bool', 0, None, True, False, 1, 1-1, 2%2] # Список значений, которые могут быть True или False
out = filter(None, bools) # Передали None вместо функции в filter()
# Вывод результата
for iter in out:
    print(iter) # bool, True, 1



''' ---------------------------------------
    Встроенная функция ROUND
''' ---------------------------------------

# Округляет число с плавающей точкой до заданной точности
round(float_number, number_of_decimals)

# Правила округления:
#    Если >= 5, то добавляется +1.
#    Если <5, то финальное значение такое же, как и до десятых

print(round(12)) # 12
print(round(21.4)) # 21
print(round(21.5)) # 22
print(round(21.7)) # 22
# когда последняя цифра 5
print(round(5.465, 2)) # 5.46
# когда последняя цифра >=5
print(round(5.476, 2)) # 5.48
# когда последняя цифра меньше 5
print(round(5.473, 2)) # 5.47

# Сокращение
print(round(565.5556, -2)) # 600

# Не баг а фича!!!
print(round(3.675, 2)) # 3.67
print(round(1.5)) # 2
print(round(2)) # 2
print(round(2.5)) # 2



''' ---------------------------------------
    МНОГОПОТОЧНОСТЬ (thread)
''' ---------------------------------------

# О потоках нужно знать следующее:
#   - Они существуют внутри процесса;
#   - В одном процессе может быть несколько потоков;
#   - Потоки в одном процессе разделяют состояние и память родительского процесса.

import threading


# Пример многопоточности
import time
from threading import Thread
def sleepMe(i):
    print("Поток %i засыпает на 5 секунд.\n" % i)
    time.sleep(5)
    print("Поток %i сейчас проснулся.\n" % i)
for i in range(10):
    th = Thread(target=sleepMe, args=(i, ))
    th.start()
# Внимание!!! Вывод при каждом запуске будет разным т.к. у параллельных потоков нет определенного порядка:
Поток 0 засыпает на 5 секунд.
Поток 1 засыпает на 5 секунд.
Поток 2 засыпает на 5 секунд.
Поток 3 засыпает на 5 секунд.
Поток 4 засыпает на 5 секунд.
Поток 5 засыпает на 5 секунд.
Поток 6 засыпает на 5 секунд.
Поток 7 засыпает на 5 секунд.
Поток 8 засыпает на 5 секунд.
Поток 9 засыпает на 5 секунд.
Поток 1 сейчас проснулся.
Поток 0 сейчас проснулся.
Поток 3 сейчас проснулся.
Поток 2 сейчас проснулся.
Поток 4 сейчас проснулся.
Поток 5 сейчас проснулся.
Поток 6 сейчас проснулся.
Поток 7 сейчас проснулся.
Поток 9 сейчас проснулся.
Поток 8 сейчас проснулся.


# Функция threading.active_count() - возвращает количество исполняемых на текущий момент потоков. 
import threading
print("Запущено потоков: %i." % threading.active_count())

# Пример:
import time
import threading
from threading import Thread
def sleepMe(i):
    print("Поток %i засыпает на 5 секунд.\n" % i)
    time.sleep(5)
    print("Поток %i сейчас проснулся.\n" % i)
for i in range(10):
    th = Thread(target=sleepMe, args=(i, ))
    th.start()
    print("Запущено потоков: %i." % threading.active_count())
# Вывод (не забывай - при каждом запуске будет меняться):
Запущено потоков: 7.
Поток 0 засыпает на 5 секунд.
Запущено потоков: 8.Поток 1 засыпает на 5 секунд.
Запущено потоков: 9.
Поток 2 засыпает на 5 секунд.
Запущено потоков: 10.Поток 3 засыпает на 5 секунд.
Запущено потоков: 11.Поток 4 засыпает на 5 секунд.
Запущено потоков: 12.Поток 5 засыпает на 5 секунд.
Запущено потоков: 13.Поток 6 засыпает на 5 секунд.
Запущено потоков: 14.Поток 7 засыпает на 5 секунд.
Запущено потоков: 15.Поток 8 засыпает на 5 секунд.
Запущено потоков: 16.Поток 9 засыпает на 5 секунд.
Поток 1 сейчас проснулся.
Поток 0 сейчас проснулся.
Поток 2 сейчас проснулся.
Поток 3 сейчас проснулся.
Поток 5 сейчас проснулся.
Поток 4 сейчас проснулся.
Поток 6 сейчас проснулся.
Поток 7 сейчас проснулся.
Поток 8 сейчас проснулся.
Поток 9 сейчас проснулся.


# Функция threading.current_thread() - возвращает исполняемый прямо сейчас поток. С ее помощью можно выполнять определенные действия с ним.
import time
import threading
from threading import Thread
def sleepMe(i):
    print("Поток %s засыпает на 5 секунд.\n" % threading.current_thread())
    time.sleep(5)
    print("Поток %s сейчас проснулся." % threading.current_thread())
# Cоздаем только четыре потока
for i in range(10):
    th = Thread(target=sleepMe, args=(i, ))
    th.start()
# Выыод:
Поток <Thread(Thread-1 (sleepMe), started 12664)> засыпает на 5 секунд.
Поток <Thread(Thread-2 (sleepMe), started 1432)> засыпает на 5 секунд.
Поток <Thread(Thread-4 (sleepMe), started 4260)> засыпает на 5 секунд.
Поток <Thread(Thread-3 (sleepMe), started 3412)> засыпает на 5 секунд.
Поток <Thread(Thread-5 (sleepMe), started 5320)> засыпает на 5 секунд.
Поток <Thread(Thread-8 (sleepMe), started 7684)> засыпает на 5 секунд.
Поток <Thread(Thread-6 (sleepMe), started 10312)> засыпает на 5 секунд.
Поток <Thread(Thread-10 (sleepMe), started 3716)> засыпает на 5 секунд.
Поток <Thread(Thread-9 (sleepMe), started 2928)> засыпает на 5 секунд.
Поток <Thread(Thread-7 (sleepMe), started 1980)> засыпает на 5 секунд.
Поток <Thread(Thread-4 (sleepMe), started 4260)> сейчас проснулся.
Поток <Thread(Thread-1 (sleepMe), started 12664)> сейчас проснулся.
Поток <Thread(Thread-3 (sleepMe), started 3412)> сейчас проснулся.
Поток <Thread(Thread-9 (sleepMe), started 2928)> сейчас проснулся.
Поток <Thread(Thread-7 (sleepMe), started 1980)> сейчас проснулся.
Поток <Thread(Thread-2 (sleepMe), started 1432)> сейчас проснулся.
Поток <Thread(Thread-8 (sleepMe), started 7684)> сейчас проснулся.
Поток <Thread(Thread-5 (sleepMe), started 5320)> сейчас проснулся.
Поток <Thread(Thread-10 (sleepMe), started 3716)> сейчас проснулся.
Поток <Thread(Thread-6 (sleepMe), started 10312)> сейчас проснулся.


# Функция threading.main_thread() - функция возвращает основной поток программы. Именно из него создаются новые потоки.
import threading
print(threading.main_thread()) # <_MainThread(MainThread, started 12620)>


# Функция threading.enumerate() - функция возвращает список всех активных потоков.
import threading
for thread in threading.enumerate():
    print("Имя потока %s." % thread.getName())
# Имя потока MainThread.
# Имя потока pydevd.Writer.
# Имя потока pydevd.Reader.
# Имя потока Thread-4.
# Имя потока pydevd.CommandThread.
# Имя потока pydevd.CheckAliveThread.


# Функция threading.Timer() - используется для создания нового потока и указания времени, через которое он должен запуститься. После запуска поток вызывает определенную функцию.
import threading
def delayed():
    print("Вывод через 5 секунд!")
thread = threading.Timer(5, delayed)
thread.start()


# Pool - класс, управляющий процессами
from multiprocessing import Pool
def cube(x):
	return x ** 3
if __name__=="__main__":
	pool= Pool(5)
	result = pool.map( cube, [0, 1, 2, 3] )
	print(result) # [0, 1, 8, 27]


# Разделение состояния между потоками - одновременный доступ к общим данным должен быть защищен блокировкой
import threading
obj={}
obj_lock=threading.Lock()
def objify(key,val):
    print("Obj имеет %d значений" % len(obj)) 
    with obj_lock:
        obj[key] = val
    print("А сейчас Obj имеет %d значений" % len(obj))
ts=[threading.Thread(target=objify, args=(str(n), n)) for n in range(4)]
for t in ts:
    t.start()
for t in ts:
    t.join()
print("Obj конечный результат:")
import pprint; pprint.pprint(obj)

# Запуск двух процессов
import multiprocessing
import time
from random import randint
def countUp():
    i=0
    while i<=3:
        print('Up:\t{}'.format(i))
        time.sleep(randint(1,3)) # ждем 1, 2, 3 секунды
        i += 1
def countDown():
    i=3
    while i >= 0:
        print('Down:\t{}'.format(i))
        time.sleep(randint(1,3))
        i -= 1
if __name__=='__main__':
    # Инициализируем процессы
    workerUp=multiprocessing.Process(target=countUp)
    workerDown=multiprocessing.Process(target=countDown)
    # Запускаем процессы
    workerUp.start()
    workerDown.start()
    # Бллокируем основной процесс
    workerUp.join()
    workerDown.join()



''' ---------------------------------------
    Инструкция assert — это булевы выражения, которые проверяют, является ли условие истинным
''' ---------------------------------------

# Assertions (утверждения) — это инструкции, которые «утверждают» определенный кейс в программе. В Python они выступают булевыми выражениями, которые проверяют, является ли условие истинным или ложным. Если оно истинно, то программа ничего не делает и переходит к выполнению следующей строчки кода.
# Если нужно симулировать или выполнить отладку кода, чтобы узнать, что именно происходит на определенном этапе, то «утверждения» в Python отлично для этого подходят. Именно инструмент отладки останавливает программу, как только возникает какая-то ошибка. Он также показывает, где именно она произошла.

assert condition # базовая структура инструкций утверждения в Python.
assert condition, message # базовая структура и добавлено сообщение для вывода при ложном условии

# Пример проверки на ноль
def divide(x, y):
    assert y != 0 , 'Нельзя делить на 0'
    return round(x/y, 2)
z = divide(21,3)
print(z) # 7
a = divide(21,0)
print(a) # Ошибка 'Нельзя делить на 0'



# Методы assert
assertEqual(x, y) # x == y	
assertNotEqual(x, y) # x != y	
assertTrue(x) # bool(x) равно True	
assertFalse(x) # bool(x) равно False	
assertIs(x, y) # x это y. Работает только c Python 3.1
assertIsNot(x, y) # x это не y. Работает только c Python 3.1
assertIsNone(x) # x это None. Работает только c Python 3.1
assertIsNotNone(x) # x это не None. Работает только c Python 3.1
assertIn(x, y) # x в y. Работает только c Python 3.1
assertNotIn(x, y) # x не в y. Работает только c Python 3.1
assertIsInstance(x, y) # isinstance(x, y). Работает только c Python 3.2
assertNotIsInstance(x,y) # не isinstance(x, y). Работает только c Python 3.2



''' ---------------------------------------
    Namedtuple (именные кортежи) 
''' ---------------------------------------

# Именованные кортежи (namedtuple) — это подкласс кортежей в Python. У них те же функции, что и у обычных, но их значения можно получать как с помощью имени (через точку, например, .name), так и с помощью индекса (например [0]).
# Namedtuple — это замена обычных кортежей. Они выполняют те же функции, но улучшают читаемость кода.

from collections import namedtuple

# Общий синтаксис namedtuple в Python
collections.namedtuple(<ИмяКортежа>, <ИменаПолейКортежа>, *, rename=False, defaults=None, module=None)

# Создание именованного кортежа
from collections import namedtuple
Marks = namedtuple('Marks', 'Физика Химия Математика Английский')
marks = Marks(90, 85, 95, 100)
print(marks) # Marks(Физика=90, Химия=85, Математика=95, Английский=100)

# Создание namedtuple с помощью списка
from collections import namedtuple
lst = [ 'Физика', 'Химия', 'Математика', 'Английский' ]
Marks = namedtuple('Marks', lst)
marks = Marks(90, 85, 95, 100)
print(marks) # Marks(Физика=90, Химия=85, Математика=95, Английский=100)

# Создание namedtuple с помощью словаря
from collections import namedtuple
dct = {'Физика': 0, 'Химия': 0, 'Математика': 0, 'Английский': 0}
Marks = namedtuple('Marks', dct)
marks = Marks(90, 85, 95, 100)
print(marks)

# Создание namedtuple с помощью кортежа
from collections import namedtuple
tupl = ('Физика', 'Химия', 'Математика', 'Английский')
Marks = namedtuple('Marks', tupl)
marks = Marks(90, 85, 95, 100)
print(marks)

# Создание namedtuple с помощью множества
from collections import namedtuple
subject_set = {'Физика', 'Химия', 'Математика', 'Английский'}
Marks = namedtuple('Marks', subject_set)
marks = Marks(90, 85, 95, 100)
print(marks)

# Создание namedtuple с помощью функции _make
from collections import namedtuple
lst = ['Физика', 'Химия', 'Математика', 'Английский']
Marks = namedtuple('Marks', lst)
marks = Marks._make([55, 78, 98, 90])
print(marks)

# Функция _make также принимает итерируемый объект (в случае со словарем — значение)
marks = Marks._make({55: 'Physics', 78: 'Chemistry', 98: 'Math', 90: 'English'})
print(marks)

# Доступ к именам полей namedtuple в python
    Через смещение.
    Через точку.
    getattr().
# Доступ к полям можно получить тем же способом, что и в кортежах — с помощью индекса.
print(marks[0])
print(marks[3])
print(marks.Physics)
print(marks.English)

# Изменение значения поля namedtuple
marks = marks._replace(Physics=99)



''' ---------------------------------------
    Функция main() 
''' ---------------------------------------

# это специальная функция, которая позволяет добавить больше логики в структуру программ. В Python можно вызвать функцию в нижней части программы, которая и будет запущена.
def main():

# Значение __name__ - при запуске здесь будет храниться имя запущенной программы
print(__name__) # __main__

# Конструкция требуется если нужно выполнить код при непосредственно запущенной программе, а не вызванной из другой програмы
if __name__ == __main__ в Python:


''' ---------------------------------------
    Функция zip() 
''' ---------------------------------------

# Cоздает итератор, который объединяет элементы из нескольких источников данных. Эта функция работает со списками, кортежами, множествами и словарями для создания списков или кортежей, включающих все эти данные.
employee_numbers = [2, 9, 18, 28]
employee_names = ["Дима", "Марина", "Андрей", "Никита"]
zipped_values = zip(employee_names, employee_numbers)
zipped_list = list(zipped_values)
print(zipped_list)# [('Дима', 2), ('Марина', 9), ('Андрей', 18), ('Никита', 28)]
print(type(zipped_values)) # <class 'zip'>

# Работа с несколькими итерируемыми объектами — один из основных сценариев использования функции zip() в Python
employee_numbers = [2, 9, 18, 28]
employee_names = ["Дима", "Марина", "Андрей", "Никита"]
for name, number in zip(employee_names, employee_numbers):
	print(name, number) # [('Дима', 2), ('Марина', 9), ('Андрей', 18), ('Никита', 28)]

# Для разъединения итерируемых объектов используется спецсимвол *
employees_zipped = [('Дима', 2), ('Марина', 9), ('Андрей', 18), ('Никита', 28)]
employee_names, employee_numbers = zip(*employees_zipped)
print(employee_names) # ("Дима", "Марина", "Андрей", "Никита")
print(employee_numbers) # (2, 9, 18, 28)

# Функция zip объединяет элементы из разных объектов(например, список или кортеж) и возвращает итератор
id = [ 1, 2, 3, 4]
leaders = [ 'Путин', 'Медведев','Мишустин','Песков']
record = zip(id,leaders)
print(list(record)) # [(1, 'Путин'), (2, 'Медведев'), (3, 'Мишустин'), (4, 'Песков')]

# Подаем на вход 1 список
print(list(zip(id))) # [(1,), (2,), (3,), (4,)]

# Подаем на вход 3 списка
record = zip( id, leaders, ['Владимир', 'Дмитрий', 'Михаил', 'Дмитрий'] )
print(list(record)) # [(1, 'Путин', 'Владимир'), (2, 'Медведев', 'Дмитрий'), (3, 'Мишустин', 'Михаил'), (4, 'Песков', 'Дмитрий')]

# Подаем на вход коллекцию разной длины - ориентация на меньшую длину!
record = zip( [1, 2], leaders)
print(list(record)) # [(1, 'Путин'), (2, 'Медведев')]

# Подаем на вход коллекцию разной длины, но ориентируемся на большую длину, пропуски заполняем аргументом fillvalue (по-умолчанию fillvalue=None)
from itertools import zip_longest
print(list(zip_longest( [1, 2], leaders))) # [(1, 'Путин'), (2, 'Медведев'), (None, 'Мишустин'), (None, 'Песков')]
print(list(zip_longest( [1, 2], leaders, fillvalue='-=Болт=-'))) # [(1, 'Путин'), (2, 'Медведев'), ('-=Болт=-', 'Мишустин'), ('-=Болт=-', 'Песков')]

# Распаковка - список кортежей разделить на отдельные списки
record = [ (1, 'Путин', 'Владимир'), (2, 'Медведев', 'Дмитрий'), (3, 'Мишустин', 'Михаил'), (4, 'Песков', 'Дмитрий') ]
id, leaders, name = zip(*record)
print(id) # (1, 2, 3, 4)
print(leaders) # ('Путин', 'Медведев', 'Мишустин', 'Песков')
print(name) # ('Владимир', 'Дмитрий', 'Михаил', 'Дмитрий')

# Создать словарь из двух списков не используя циклы
# 1-й способ
leader_dict = {i: name for i, name in zip(id, leaders)}
print(leader_dict) # {1: 'Путин', 2: 'Медведев', 3: 'Мишустин', 4: 'Песков'}
# 2-й способ
leader_dict2 = dict(zip(id,leaders))
print(leader_dict2) # {1: 'Путин', 2: 'Медведев', 3: 'Мишустин', 4: 'Песков'}

# Итерация по нескольким коллекциям без индексации
products = [ 'вишня', 'черешня', 'яблоки']
price = [ 2.5, 3, 5 ]
cost = [ 1, 1.5, 2]
for prod, p, c in zip(products, price, cost):
    print(f'Профит по {prod} получается ${p-c}')    # Профит по вишня получается $1.5
                                                    # Профит по черешня получается $1.5
                                                    # Профит по яблоки получается $3

# Транспонирование матрицы в одну строку
matrix = [ [1,5,6], [2,7,8], [3,9,10] ]
print( [ list(i) for i in zip(*matrix) ] ) # [[1, 2, 3], [5, 7, 9], [6, 8, 10]]


''' ---------------------------------------
    Работа с файлами 
''' ---------------------------------------

# Открытие файла
f=open(filename, access_mode)
# filename - имя файла
# access_mode - режим открытия файла:
    'r'	- открытие на чтение (является значением по умолчанию).
    'w'	- открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
    'x'	- открытие на запись, если файла не существует, иначе исключение.
    'a'	- открытие на дозапись, информация добавляется в конец файла.
    'b'	- открытие в двоичном режиме.
    't'	- открытие в текстовом режиме (является значением по умолчанию).
    '+'	- открытие на чтение и запись
# Режимы могут быть объеденены: 'rb', 'rb+'
# Режим по-умолчанию 'rt'

f=open('C:/1/primer1.txt','r')
print (*f) # Вывод содержимого файла
print (f) # Вывод наименование объекта: <_io.TextIOWrapper name='C:/1/primer1.txt' mode='r' encoding='cp1251'>

f.close() # закрытие файла вариант № 1

# Зарытие файла вариант № 2
f=open('C:/1/primer1.txt','r')
try:
   # работа с файлом
finally:
   f.close()

# Закрытие файла вариант № 3 - тут можно не использовать метод f.close()
with open('C:/1/primer1.txt','r') as f:
    # работа с файлом

# Чтение из файла
f.read(size)
    # size - кол-во символов которые надо прочесть

# Прочитать весь файл и вывести его на экран
f=open('C:/1/primer1.txt','r')
for txt in f:
    print(txt)
f.close()

f.read(7) # считать первые 7 символов
f.readline() # считать линию символов
f.write('следующая линия') # записать что-то в файл открытый для записи

f.tell() # возвращает текущую позицию курсора в файле\
f.seek(0,0) # возвращает курсор в начало файла

# В файлах Windows кодировка cp-1251, в файлах Linux utf-8

# Общие методы:
file.close()	# закрывает открытый файл
file.fileno()	# возвращает целочисленный дескриптор файла
file.flush()	# очищает внутренний буфер
file.isatty()	# возвращает True, если файл привязан к терминалу
file.next()	    # возвращает следующую строку файла
file.read(n)	# чтение первых n символов файла
file.readline()	#читает одну строчку строки или файла
file.readlines()	# читает и возвращает список всех строк в файле
file.seek(offset[,whene])	# устанавливает текущую позицию в файле
file.seekable()	# проверяет, поддерживает ли файл случайный доступ. Возвращает True, если да
file.tell()	    # возвращает текущую позицию в файле
file.truncate(n)	# уменьшает размер файл. Если n указала, то файл обрезается до n байт, если нет — до текущей позиции
file.write(str)	    # добавляет строку str в файл
file.writelines(sequence)	#добавляет последовательность строк в файл

# Запись в файл списка
l = [str(i)+str(i-1) for i in range(20)] # создали список
f=open('c:/1/list.txt','w') # файл для записи
for txt in l:
    f.write(txt + '\n')
f.close()

# чтения списка из файла
f=open('c:/1/list.txt','r') # файл для записи
l2 = [line.strip() for line in f]
f.close()
print(l2)

# Считать файл по-строчно в список
with open("file.txt") as f:
	content = f.readlines()		# Считали по-строчно содержимое файла в переменную
content = [x.strip() for x in content]	# удалили символы новой строки
print(content)	# ['1 строка файла', '2 строка файла', '3 строка файла', 'и т.д.']

# Библиотека работы с файлами и каталогами OSError
import os 

os.rename('старый_файл', 'новый файл')  # переименовывание файла
os.replace('renamed-text.txt','folder/renamed-text.txt')    # переместить файл. Если в такой файл уже есть - будет перезаписан
os.getcwd() # вывод текущей директории
os.mkdir('folder')  # создать директорию без проверки на наличие такой директории (если директория есть будет ошибка FileExistsError)
if not os.path.isdir("folder"):
     os.mkdir("folder") # создать директорию с проверкой на наличие такой директории
os.chdir('folder')  # сменить директорию
os.chdir('..')  # вернуться на директорию выше
os.makedirs("nested1/nested2/nested3")  # создать несколько вложенных директорий
os.listdir()    # список файлов и каталогов в директории (не рекурсивно!!!)

os.walk()   # список файлов и директорий рекурсивно
for dirpath, dirnames, filenames in os.walk("."):
    # перебрать каталоги
    for dirname in dirnames:
        print("Каталог:", os.path.join(dirpath, dirname))
    # перебрать файлы
    for filename in filenames:
        print("Файл:", os.path.join(dirpath, filename))

os.remove("filename.txt")		# удалить файл (но не директорию!)
os.rmdir("folder")	# удалить каталог не рекурсивно
os.removedirs("folder")		# удалить каталог (пустой!) рекурсивно

os.stat("filename.txt")		# возвращает кортеж с информацией о файлe:
os.stat("filename.txt").st_size # выводит только один аттрибут st_size
# os.stat_result(st_mode=33206, st_ino=56294995342251250, st_dev=250090584, st_nlink=1, st_uid=0, st_gid=0, st_size=47, st_atime=1641453757, st_mtime=1641453757, st_ctime=1641449917)
    st_mode     # тип файла: 33206 текстовый
    st_ino      # уникальный идентификатор (inode в Linux, file index в Windows)
    st_dev      # Идентификатор устройства, где хранится файл
    st_nlink    # Число жестких ссылок на файл
    st_uid      # Идентификатор владельца файла
    st_gid      # Идентификатор группы владельца файла
    st_size     # размер файла в байтах
    st_atime    # время последнего доступа в секундах (временная метка)
    st_mtime    # время последнего изменения
    st_ctime    # в Windows это время создания файла, а в Linux — последнего изменения метаданных
print(os.stat("filename.txt").st_size)  # Вывод только размера файла
    st_atime_ns # 
    st_mtime_ns #
    st_ctime_ns # 
### В Linux выводится еще несколько значений:
    st_blocks   # Number of 512-byte blocks allocated for file. This may be smaller than st_size/512 when the file has holes.
    st_blksize  # “Preferred” blocksize for efficient file system I/O. Writing to a file in smaller chunks may cause an inefficient read-modify-rewrite.
    st_rdev     # Type of device if an inode device.
    st_flags    # User defined flags for file.

### On other Unix systems (such as FreeBSD), the following attributes may be available (but may be only filled out if root tries to use them):
    st_gen      # File generation number.
    st_birthtime    # Time of file creation.

### On Solaris and derivatives, the following attributes may also be available:
    st_fstype   # String that uniquely identifies the type of the filesystem that contains the file.

### On macOS systems, the following attributes may also be available:
    st_rsize    # Real size of the file.
    st_creator  # Creator of the file.
    st_type     # File type.

### On Windows systems, the following attributes are also available:
    st_file_attributes # Windows file attributes: dwFileAttributes member of the BY_HANDLE_FILE_INFORMATION structure returned by GetFileInformationByHandle(). See the FILE_ATTRIBUTE_* constants in the stat module.
    st_reparse_tag      # When st_file_attributes has the FILE_ATTRIBUTE_REPARSE_POINT set, this field contains the tag identifying the type of reparse point. See the IO_REPARSE_TAG_* constants in the stat module.

os.path.isfile('filename.txt') # True - если это является файлом
os.path.isdir('folder') # True - если это является каталогом

import os
if os.path.exists("demofile.txt"):
	os.remove("deomofile.txt")
else:
	print("Файл для удаления отсутствует.")




''' ---------------------------------------
    MATH - математический модуль 
''' ---------------------------------------

import math
x=1.55
y=-1.55

# ближайшее целое число. Меньше чем х
math.floor(x) # 1
math.floor(y) # -2
# ближайшее целое число. Больше чем х
math.ceil(x) # 2
math.ceil(y) # -1
# отбросить дробную часть
math.trunc(x) # 1
math.trunc(y) # -1



''' ---------------------------------------
    RE - модуль группировки
''' ---------------------------------------

# Группировка
import re
sentence="Мой номер телефона в Москве 8-913-508-69-75"
pattern=r".*(телефон).*?([\d-]+)"
match=re.match(pattern,sentence)
print( match.groups() ) # Кортеж ('телефон', '8-913-508-69-75')
print( match.group() ) # Возвращаем полностью как строку "Мой номер телефона в Москве 8-913-508-69-75"
print( match.group(0) ) # Возвращаем полностью как строку "Мой номер телефона в Москве 8-913-508-69-75"
print( match.group(1) ) # "Телефон" - 1-я подгруппа в скобках
print( match.group(2) ) # "8-913-508-69-75" - 2-я подгруппа в скобках
print( match.group(1, 2) ) # ('телефон', '8-913-508-69-75') - несколько подгрупп в кортеже

# Проверка символов на допустимость
import re
def is_allowed(string):
	characterRegex = re.compile(r'[^a-zA-Z0-9.]')
	string = characterRegex.search(string)
	return not bool(string)
print (is_allowed("abcdABCDZ2009")) # True
print (is_allowed("!@#$%^^")) # False



''' ---------------------------------------
    turtle - модуль рисования
''' ---------------------------------------

import turtle
ninja = turtle.Turtle() # Рисует стрелочка
turtle.reset()          # очищает холст и возвращает курсор в начало координат
ninja.hideturtle()     # скрывает черепашку (или стрелку, курсор)
ninja.setup(800, 800)  # устанавливает размеры окна в 800 на 400 пикселей
ninja.pencolor('blue')  # Рисуем синим цветом
ninja.circle(120)       # РИсуем круг
ninja.seth(0)       # # устанавливает направление в градусах. 0 – горизонтально направо (на восток), 90 – вверх (на север) и так далее
ninja.setpos(0, 0)      # устанавливает черепашку (курсор) в позицию с координатами (x, y)
ninja.shape('turtle')   # Рисует черепашка
ninja.color('red','green')  # Рисуем RED, черепашка GREEN
ninja.begin_fill()  # Начало заливки
ninja.speed(10) # Скорость анимации
for i in range(180):
    ninja.forward(100)  # Движение вперед
    ninja.right(30)     # Поворот вправо
    ninja.backward(5)   # Движение назад
    ninja.right(30)
    ninja.forward(20)   
    ninja.left(60)      # Поворот влево
    ninja.forward(50)
    ninja.right(30)
    ninja.penup()       # Не рисовать во время движения
    ninja.setposition(0,0)  # Устанавоиваем в новую позицию
    ninja.pendown()     # Рисовать во время движения
    ninja.right(1)
ninja.end_fill()  # Конец заливки
turtle.exitonclick()    # выйти при клике на канвасе
# turtle.clear()          # очищает холст от нарисованного
turtle.done()       # Конец



''' ---------------------------------------
    sqlite3 - модуль базы данных SQL
''' ---------------------------------------

import sqlite3
conn = sqlite3.connect("users.db") # Создаем объект, представляющий базу данных
c = conn.cursor() # создаем объект для выполнения команд
c.execute("CREATE TABLE user (name, age integer)") # СОздаем таблицу
c.execute("INSERT INTO user VALUES ('User1', 42)") # Добавляем 1-ю запись в таблицу
c.execute("INSERT INTO user VALUES ('User2', 37)") # Добавляем 2-ю запись в таблицу
conn.commit() # Сохраняем изменения
# Выводим содержимое таблицы на экран
c.execute("SELECT * FROM user") 
print(c.fetchall())
conn.close # Закрываем работу с базой



''' ---------------------------------------
    xlrd - модуль для работы с файлами Excel
''' ---------------------------------------
pip install xlrd

import xlrd
book = xlrd.open_workbook('sample.xlsx') # ПРивязываем объект с файлу Excel
print(book.nsheets) # Кол-листов в книге
print(book.sheet_names()) # Список имен листов в книге
sheets = book.sheet_names() # Привязываем объект к списку листов по имени
cur_sheet = book.sheet_by_name(sheets[0]) # Привязываем объект к первому попавшемуся листу 
sheet = book.sheet_by_index(1) # Привязываем объект к листу по индексу
cell = sheet.cell(row, col) # Привязываем объект к ячейке(row-номер строки, col-номер столбца)
print(cell.value) # Выводим содержимое ячейки на экран
num_rows = sheet.num_rows # Кол-во строк
num_col = sheet.ncols # Кол-во столбцов


''' ---------------------------------------
    Кортежи синусов и косинусов
''' ---------------------------------------

lst_sin = ( 0.0, 0.01745240643728351, 0.03489949670250097, 0.052335956242943835, 0.0697564737441253, 0.08715574274765817, 0.10452846326765347, 0.12186934340514748, 0.13917310096006544, 0.15643446504023087, 0.17364817766693033, 0.1908089953765448, 0.20791169081775934, 0.224951054343865, 0.24192189559966773, 0.25881904510252074, 0.27563735581699916, 0.29237170472273677, 0.3090169943749474, 0.3255681544571567, 0.3420201433256687, 0.35836794954530027, 0.374606593415912, 0.39073112848927377, 0.4067366430758002, 0.42261826174069944, 0.4383711467890774, 0.45399049973954675, 0.4694715627858908, 0.48480962024633706, 0.49999999999999994, 0.5150380749100542, 0.5299192642332049, 0.5446390350150271, 0.5591929034707469, 0.573576436351046, 0.5877852522924731, 0.6018150231520483, 0.6156614753256583, 0.6293203910498374, 0.6427876096865393, 0.6560590289905073, 0.6691306063588582, 0.6819983600624985, 0.6946583704589973, 0.7071067811865476, 0.7193398003386512, 0.7313537016191705, 0.7431448254773942, 0.754709580222772, 0.766044443118978, 0.7771459614569709, 0.788010753606722, 0.7986355100472928, 0.8090169943749475, 0.8191520442889918, 0.8290375725550417, 0.838670567945424, 0.8480480961564261, 0.8571673007021123, 0.8660254037844386, 0.8746197071393957, 0.8829475928589269, 0.8910065241883678, 0.898794046299167, 0.9063077870366499, 0.9135454576426009, 0.9205048534524404, 0.9271838545667874, 0.9335804264972017, 0.9396926207859083, 0.9455185755993167, 0.9510565162951535, 0.9563047559630354, 0.9612616959383189, 0.9659258262890683, 0.9702957262759965, 0.9743700647852352, 0.9781476007338056, 0.981627183447664, 0.984807753012208, 0.9876883405951378, 0.9902680687415704, 0.992546151641322, 0.9945218953682733, 0.9961946980917455, 0.9975640502598242, 0.9986295347545738, 0.9993908270190958, 0.9998476951563913, 1.0, 0.9998476951563913, 0.9993908270190958, 0.9986295347545738, 0.9975640502598242, 0.9961946980917455, 0.9945218953682733, 0.9925461516413221, 0.9902680687415704, 0.9876883405951378, 0.984807753012208, 0.981627183447664, 0.9781476007338057, 0.9743700647852352, 0.9702957262759965, 0.9659258262890683, 0.9612616959383189, 0.9563047559630355, 0.9510565162951536, 0.9455185755993168, 0.9396926207859084, 0.9335804264972017, 0.9271838545667874, 0.9205048534524403, 0.9135454576426009, 0.90630778703665, 0.8987940462991669, 0.8910065241883679, 0.8829475928589269, 0.8746197071393959, 0.8660254037844387, 0.8571673007021123, 0.8480480961564261, 0.838670567945424, 0.8290375725550417, 0.8191520442889917, 0.8090169943749475, 0.7986355100472927, 0.788010753606722, 0.777145961456971, 0.766044443118978, 0.7547095802227721, 0.7431448254773942, 0.7313537016191706, 0.7193398003386511, 0.7071067811865476, 0.6946583704589971, 0.6819983600624985, 0.6691306063588583, 0.6560590289905073, 0.6427876096865395, 0.6293203910498374, 0.6156614753256584, 0.6018150231520482, 0.5877852522924732, 0.5735764363510459, 0.5591929034707469, 0.5446390350150273, 0.5299192642332049, 0.5150380749100544, 0.49999999999999994, 0.48480962024633717, 0.4694715627858907, 0.45399049973954686, 0.4383711467890773, 0.4226182617406995, 0.40673664307580043, 0.39073112848927377, 0.37460659341591224, 0.3583679495453002, 0.3420201433256689, 0.3255681544571566, 0.3090169943749475, 0.2923717047227366, 0.2756373558169992, 0.258819045102521, 0.24192189559966773, 0.2249510543438652, 0.20791169081775931, 0.19080899537654497, 0.17364817766693028, 0.15643446504023098, 0.13917310096006533, 0.12186934340514755, 0.10452846326765373, 0.0871557427476582, 0.06975647374412552, 0.05233595624294381, 0.03489949670250114, 0.01745240643728344, 1.2246467991473532e-16, -0.017452406437283637, -0.0348994967025009, -0.052335956242943564, -0.06975647374412527, -0.08715574274765794, -0.1045284632676535, -0.12186934340514731, -0.13917310096006552, -0.15643446504023073, -0.17364817766693047, -0.19080899537654472, -0.2079116908177595, -0.22495105434386498, -0.2419218955996675, -0.2588190451025208, -0.275637355816999, -0.29237170472273677, -0.3090169943749473, -0.32556815445715676, -0.34202014332566866, -0.35836794954530043, -0.374606593415912, -0.39073112848927355, -0.4067366430758002, -0.4226182617406993, -0.43837114678907746, -0.45399049973954664, -0.46947156278589086, -0.48480962024633695, -0.5000000000000001, -0.5150380749100542, -0.5299192642332048, -0.5446390350150271, -0.5591929034707467, -0.5735764363510462, -0.587785252292473, -0.6018150231520484, -0.6156614753256582, -0.6293203910498376, -0.6427876096865393, -0.656059028990507, -0.6691306063588582, -0.6819983600624984, -0.6946583704589973, -0.7071067811865475, -0.7193398003386512, -0.7313537016191705, -0.7431448254773944, -0.754709580222772, -0.7660444431189779, -0.7771459614569706, -0.7880107536067221, -0.7986355100472928, -0.8090169943749473, -0.8191520442889916, -0.8290375725550418, -0.8386705679454242, -0.848048096156426, -0.8571673007021121, -0.8660254037844385, -0.8746197071393959, -0.882947592858927, -0.8910065241883678, -0.8987940462991668, -0.9063077870366502, -0.913545457642601, -0.9205048534524403, -0.9271838545667873, -0.9335804264972016, -0.9396926207859084, -0.9455185755993168, -0.9510565162951535, -0.9563047559630353, -0.961261695938319, -0.9659258262890683, -0.9702957262759965, -0.9743700647852351, -0.9781476007338056, -0.981627183447664, -0.984807753012208, -0.9876883405951377, -0.9902680687415703, -0.9925461516413221, -0.9945218953682734, -0.9961946980917455, -0.9975640502598242, -0.9986295347545738, -0.9993908270190958, -0.9998476951563913, -1.0, -0.9998476951563913, -0.9993908270190958, -0.9986295347545738, -0.9975640502598243, -0.9961946980917455, -0.9945218953682734, -0.992546151641322, -0.9902680687415704, -0.9876883405951378, -0.9848077530122081, -0.9816271834476639, -0.9781476007338056, -0.9743700647852352, -0.9702957262759966, -0.9659258262890684, -0.9612616959383188, -0.9563047559630354, -0.9510565162951536, -0.945518575599317, -0.9396926207859083, -0.9335804264972017, -0.9271838545667874, -0.9205048534524405, -0.9135454576426011, -0.9063077870366498, -0.898794046299167, -0.891006524188368, -0.8829475928589271, -0.8746197071393956, -0.8660254037844386, -0.8571673007021123, -0.8480480961564261, -0.8386705679454243, -0.8290375725550416, -0.8191520442889918, -0.8090169943749476, -0.798635510047293, -0.7880107536067218, -0.7771459614569708, -0.7660444431189781, -0.7547095802227722, -0.7431448254773946, -0.7313537016191703, -0.7193398003386511, -0.7071067811865477, -0.6946583704589976, -0.6819983600624983, -0.6691306063588581, -0.6560590289905074, -0.6427876096865396, -0.6293203910498378, -0.6156614753256582, -0.6018150231520483, -0.5877852522924734, -0.5735764363510465, -0.5591929034707466, -0.544639035015027, -0.529919264233205, -0.5150380749100545, -0.5000000000000004, -0.4848096202463369, -0.4694715627858908, -0.45399049973954697, -0.4383711467890778, -0.4226182617406992, -0.40673664307580015, -0.3907311284892739, -0.37460659341591235, -0.35836794954530077, -0.3420201433256686, -0.3255681544571567, -0.3090169943749477, -0.29237170472273716, -0.27563735581699894, -0.2588190451025207, -0.24192189559966787, -0.22495105434386534, -0.20791169081775987, -0.19080899537654467, -0.1736481776669304, -0.1564344650402311, -0.13917310096006588, -0.12186934340514723, -0.10452846326765342, -0.08715574274765832, -0.06975647374412564, -0.05233595624294437, -0.034899496702500823, -0.01745240643728356 )

lst_cos = ( 1.0, 0.9998476951563913, 0.9993908270190958, 0.9986295347545738, 0.9975640502598242, 0.9961946980917455, 0.9945218953682733, 0.992546151641322, 0.9902680687415704, 0.9876883405951378, 0.984807753012208, 0.981627183447664, 0.9781476007338057, 0.9743700647852352, 0.9702957262759965, 0.9659258262890683, 0.9612616959383189, 0.9563047559630354, 0.9510565162951535, 0.9455185755993168, 0.9396926207859084, 0.9335804264972017, 0.9271838545667874, 0.9205048534524404, 0.9135454576426009, 0.9063077870366499, 0.898794046299167, 0.8910065241883679, 0.882947592858927, 0.8746197071393957, 0.8660254037844387, 0.8571673007021123, 0.848048096156426, 0.838670567945424, 0.8290375725550417, 0.8191520442889918, 0.8090169943749475, 0.7986355100472928, 0.7880107536067219, 0.7771459614569709, 0.766044443118978, 0.754709580222772, 0.7431448254773942, 0.7313537016191705, 0.7193398003386512, 0.7071067811865476, 0.6946583704589973, 0.6819983600624985, 0.6691306063588582, 0.6560590289905073, 0.6427876096865394, 0.6293203910498375, 0.6156614753256583, 0.6018150231520484, 0.5877852522924731, 0.573576436351046, 0.5591929034707468, 0.5446390350150271, 0.5299192642332049, 0.5150380749100542, 0.5000000000000001, 0.4848096202463371, 0.46947156278589086, 0.4539904997395468, 0.43837114678907746, 0.42261826174069944, 0.4067366430758002, 0.3907311284892737, 0.37460659341591196, 0.3583679495453004, 0.3420201433256688, 0.32556815445715676, 0.30901699437494745, 0.29237170472273677, 0.27563735581699916, 0.25881904510252074, 0.24192189559966767, 0.22495105434386492, 0.20791169081775945, 0.19080899537654492, 0.17364817766693041, 0.15643446504023092, 0.13917310096006547, 0.12186934340514749, 0.10452846326765346, 0.08715574274765814, 0.06975647374412523, 0.052335956242943966, 0.03489949670250108, 0.0174524064372836, 6.123233995736766e-17, -0.017452406437283477, -0.034899496702500955, -0.05233595624294384, -0.06975647374412533, -0.08715574274765824, -0.10452846326765355, -0.12186934340514737, -0.13917310096006535, -0.1564344650402308, -0.1736481776669303, -0.1908089953765448, -0.20791169081775934, -0.22495105434386503, -0.24192189559966779, -0.25881904510252085, -0.27563735581699905, -0.29237170472273666, -0.30901699437494734, -0.32556815445715664, -0.3420201433256687, -0.35836794954530027, -0.37460659341591207, -0.3907311284892738, -0.40673664307580026, -0.42261826174069933, -0.4383711467890775, -0.45399049973954675, -0.4694715627858909, -0.484809620246337, -0.4999999999999998, -0.5150380749100543, -0.5299192642332048, -0.5446390350150271, -0.5591929034707467, -0.5735764363510462, -0.587785252292473, -0.6018150231520484, -0.6156614753256583, -0.6293203910498373, -0.6427876096865394, -0.6560590289905072, -0.6691306063588582, -0.6819983600624984, -0.6946583704589974, -0.7071067811865475, -0.7193398003386513, -0.7313537016191705, -0.7431448254773941, -0.754709580222772, -0.7660444431189779, -0.7771459614569709, -0.7880107536067219, -0.7986355100472929, -0.8090169943749473, -0.8191520442889919, -0.8290375725550416, -0.8386705679454239, -0.848048096156426, -0.8571673007021122, -0.8660254037844387, -0.8746197071393957, -0.882947592858927, -0.8910065241883678, -0.898794046299167, -0.9063077870366499, -0.9135454576426008, -0.9205048534524404, -0.9271838545667873, -0.9335804264972017, -0.9396926207859083, -0.9455185755993168, -0.9510565162951535, -0.9563047559630355, -0.9612616959383189, -0.9659258262890682, -0.9702957262759965, -0.9743700647852351, -0.9781476007338057, -0.981627183447664, -0.984807753012208, -0.9876883405951377, -0.9902680687415704, -0.992546151641322, -0.9945218953682733, -0.9961946980917455, -0.9975640502598242, -0.9986295347545738, -0.9993908270190958, -0.9998476951563913, -1.0, -0.9998476951563913, -0.9993908270190958, -0.9986295347545738, -0.9975640502598242, -0.9961946980917455, -0.9945218953682733, -0.9925461516413221, -0.9902680687415703, -0.9876883405951378, -0.984807753012208, -0.981627183447664, -0.9781476007338056, -0.9743700647852352, -0.9702957262759965, -0.9659258262890683, -0.9612616959383189, -0.9563047559630354, -0.9510565162951536, -0.9455185755993167, -0.9396926207859084, -0.9335804264972017, -0.9271838545667874, -0.9205048534524404, -0.9135454576426009, -0.90630778703665, -0.8987940462991669, -0.8910065241883679, -0.8829475928589269, -0.8746197071393959, -0.8660254037844386, -0.8571673007021123, -0.8480480961564261, -0.838670567945424, -0.8290375725550417, -0.8191520442889918, -0.8090169943749475, -0.7986355100472928, -0.788010753606722, -0.7771459614569708, -0.766044443118978, -0.7547095802227721, -0.7431448254773942, -0.7313537016191706, -0.7193398003386511, -0.7071067811865477, -0.6946583704589973, -0.6819983600624986, -0.6691306063588581, -0.6560590289905073, -0.6427876096865395, -0.6293203910498378, -0.6156614753256581, -0.6018150231520483, -0.5877852522924732, -0.5735764363510464, -0.5591929034707466, -0.544639035015027, -0.529919264233205, -0.5150380749100544, -0.5000000000000004, -0.48480962024633684, -0.46947156278589075, -0.4539904997395469, -0.43837114678907774, -0.42261826174069916, -0.4067366430758001, -0.3907311284892738, -0.3746065934159123, -0.3583679495453007, -0.34202014332566855, -0.32556815445715664, -0.30901699437494756, -0.2923717047227371, -0.2756373558169989, -0.25881904510252063, -0.24192189559966779, -0.22495105434386525, -0.2079116908177598, -0.1908089953765446, -0.17364817766693033, -0.15643446504023104, -0.13917310096006583, -0.12186934340514717, -0.10452846326765336, -0.08715574274765825, -0.06975647374412558, -0.052335956242944306, -0.03489949670250076, -0.017452406437283498, -1.8369701987210297e-16, 0.01745240643728313, 0.03489949670250128, 0.052335956242943946, 0.06975647374412522, 0.08715574274765789, 0.10452846326765299, 0.12186934340514768, 0.13917310096006547, 0.15643446504023067, 0.17364817766692997, 0.1908089953765451, 0.20791169081775943, 0.22495105434386492, 0.24192189559966742, 0.2588190451025203, 0.2756373558169994, 0.2923717047227367, 0.30901699437494723, 0.3255681544571563, 0.342020143325669, 0.3583679495453004, 0.37460659341591196, 0.3907311284892735, 0.40673664307579976, 0.4226182617406996, 0.4383711467890774, 0.45399049973954664, 0.4694715627858904, 0.4848096202463373, 0.5000000000000001, 0.5150380749100542, 0.5299192642332047, 0.5446390350150266, 0.559192903470747, 0.573576436351046, 0.5877852522924729, 0.6018150231520479, 0.6156614753256585, 0.6293203910498375, 0.6427876096865393, 0.656059028990507, 0.6691306063588578, 0.6819983600624986, 0.6946583704589973, 0.7071067811865474, 0.7193398003386509, 0.7313537016191707, 0.7431448254773942, 0.7547095802227719, 0.7660444431189778, 0.7771459614569706, 0.788010753606722, 0.7986355100472928, 0.8090169943749473, 0.8191520442889916, 0.8290375725550418, 0.838670567945424, 0.8480480961564258, 0.8571673007021121, 0.8660254037844384, 0.8746197071393959, 0.882947592858927, 0.8910065241883678, 0.8987940462991668, 0.90630778703665, 0.913545457642601, 0.9205048534524403, 0.9271838545667873, 0.9335804264972015, 0.9396926207859084, 0.9455185755993168, 0.9510565162951535, 0.9563047559630353, 0.9612616959383189, 0.9659258262890683, 0.9702957262759965, 0.9743700647852351, 0.9781476007338056, 0.981627183447664, 0.984807753012208, 0.9876883405951377, 0.9902680687415703, 0.9925461516413221, 0.9945218953682733, 0.9961946980917455, 0.9975640502598242, 0.9986295347545738, 0.9993908270190958, 0.999847695156391 )


''' ---------------------------------------
    Работа с изображениями
''' ---------------------------------------

from PIL import image
img = Image.open("my_image.png") # Загружаем картинку
result = img.rotate(90) # Поворачиваем картинку
result.save("my_image_2.png") # Сохраняем картинку


''' ---------------------------------------
    Колода карт
''' ---------------------------------------
import random
import itertools
SUITS='чбпк'
RANKS='23456789АВДКТ'
DECK = list(''.join(card) for card in itertools.product(RANKS, SUITS))
DECK.append('JO')
hand = random.sample(DECK,6)
print(hand)



''' ---------------------------------------
    Разница между двумя массивами
''' ---------------------------------------

def differ(a, b):
	b = set(b)
	return [item for item in a if item not in b]

a = [1, 2, 3]
b = [2]
print(differ(a,b)) 	# [1, 3]


''' ---------------------------------------
    Counter.elements()
''' ---------------------------------------

from collections import Counter
cnt=Counter(a = 4, b = 2, c = 0, d = -2)
sorted(cnt.elements())	# ['a', 'a', 'a', 'a', 'b', 'b']


''' ---------------------------------------
    Римское исчисление
''' ---------------------------------------

all_roman = [ (1000, 'M'),  (900, 'CM'), (500,'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ]
def to_roman(num):
    '''
	Функция переводит десятичное число в римское исчисление
    '''
    roman=''
    while num > 0:
        for i, r in all_roman:
            while num >= i:
                roman += r
                num -= i
    return roman
# функция перевода римского числа в десятичную систему счисления
def to_dec(rom):
    '''
	Функция переводит римскую цифру в десятичное исчисление
    '''
    # на старте десятичное число равно нулю
    dec = 0
    # перебираем все пары из словаря
    for i, r in all_roman:
        # пока римское число начинается буквы из словаря
        while rom.startswith(r):
            # увеличиваем десятичное число на соответствующее значение из словаря
            dec += i
            # убираем найденную букву из римского числа
            rom = rom[len(r):]
    # как все циклы закончились — возвращаем десятичное число
    return dec
number = 15
print (f'Число {number} в римском исчислении будет {to_roman(number)}')	# XV
number2 = 'MMXXII'
print (f'Число {number2} в десятичном исчислении {to_dec(number2)}') # 2022


''' ---------------------------------------
    Генерация предложений из слов
''' ---------------------------------------

import random

nouns = ("щенок", "машина", "кролик", "девочка", "обезъяна")
verbs = ("бежит", "прыгает", "бьет", "водит", "скачет")
adv = ("бешено", "сложно", "неистово", "жадно", "точно")
adj = ("ближе", "дальше", "выше", "ниже", "короче")

l = [nouns, verbs, adj, adv]
print(' '.join([random.choice(i) for i in l]))



''' ---------------------------------------
	TKinter - встроенная библиотека GUI
''' ---------------------------------------
https://pythonru.com/uroki/obuchenie-python-gui-uroki-po-tkinter#Добавление-виджетов-на-вкладку

from tkinter import *
from tkinter.ttk import Combobox
from tkinter.ttk import Checkbutton
from tkinter import scrolledtext
from tkinter import messagebox
from tkinter.ttk import Progressbar
from tkinter import ttk
from tkinter import filedialog
from tkinter import Menu


def clicker():
    '''
    Обработка нажатия кнопки Button
    '''
    res = "Привет {}".format(txt.get()) 
    lbl.configure(text=res)

def clicked():
    '''
    Обработка выбора второй RadioButton
    '''
    lbl.configure(text=selected.get()) 

# Создаем окно
window = Tk()
window.title("Тест по огневой подготовке")
window.geometry('1200x600')     # Размер окна

# добавим панель меню
mymenu = Menu(window)
item1 = Menu(mymenu, tearoff=0)    # Создаем список выпадающий из меню "Файл" с отключением начальной пунктирной линии
item1.add_command(label='Создать', command=clicker)
item1.add_command(label='Открыть')
item1.add_command(label='Сохранить')
item1.add_separator()   # добавим разделитель
item1.add_command(label='Закрыть', command=exit)
item2 = Menu(mymenu)    # Создаем список выпадающий из меню "Правка" с начальной пунктирной линией
item2.add_command(label='Отменить')
item2.add_command(label='Повторить')
item2.add_command(label='Выделить')
mymenu.add_cascade(label='Файл', menu=item1)    # Создаем пункт меню "Файл" с выпадающим списком
mymenu.add_cascade(label='Правка', menu=item2)  # Создаем пункт меню "Правка" с выпадающим списком
mymenu.add_command(label='Об авторе')   #   Создаем пунккт меню "Об авторе" без всякого выпадающего списка
window.config(menu=mymenu)

# Добавим вкладки
myTabs = ttk.Notebook(window)   # Создаем группу вкладок
tab1 = ttk.Frame(myTabs)    # Создаем 1-ю вкладку
tab2 = ttk.Frame(myTabs)    # Создаем 2-ю вкладку
myTabs.add(tab1, text="Первая вкладка") # Добавляем в нашу группу вкладок 1-ю вкладку
myTabs.add(tab2, text="Вторая вкладка") # Добавляем в нашу группу вкладок 2-ю вкладку
lbl1 = Label(tab1, text='Это первая вкладка')   # Создаем надпись внутри 1-й вкладки
lbl3 = Label(tab1, text='Строка №2')    # Создаем надпись внутри 1-й вкладки
lbl1.grid(padx=50, pady=50)
lbl3.grid(ipadx=5, ipady=5)
lbl2 = Label(tab2, text='Это вторая вкладка')   # Создаем надпись внутри 2-й вкладки
lbl2.grid(padx=10,pady=10)
myTabs.pack(expand=1, fill='both')  # Объединяем вкладки

# Добавляем надпись Label на форму
lbl = Label(window, text="Вопросы по огневой подготовке", font=("Arial Bold", 25))
lbl.grid(column=2, row=0)

# Добавляем текстовое поле на форму
txt = Entry(window, width=10, state="normal")
txt.grid(column=2, row=1)
txt.focus()     # Курсор на этот элемент

# Добавляем внизспадающий список с кучей значений
combo = Combobox(window)
combo['values'] = ("Первый", "Второй", "Третий", 4, 5, "Последний")
combo.current(1)    # установили элемент по-умолчанию "Второй"
combo.grid(column=2, row=2)
print(combo.get())     # Печатаем выбранный элемент т.е. "Второй"

# Добавляем кнопку с обработкой нажатия 
btn= Button(window, text="Ответ", bg="white", fg="black", command=clicker)
btn.grid(column=2, row=3)

# Добавляем чекбокс (квадратный)
chk = Checkbutton(window, text='Выбрать')
chk_state = BooleanVar()  
chk_state.set(True)  # Устанавливаем состояние чекбокса "включен"
chk = Checkbutton(window, text='Выбрать', var=chk_state)  
chk.grid(column=2, row=4) 

# Добавляем Radio-button
selected=IntVar()
rad1 = Radiobutton(window, text="Первая кнопка", value = 1, state="active", variable=selected)
rad2 = Radiobutton(window, text='Вторая кнопка', value = 2, command=clicked, state="active", variable=selected)  
rad3 = Radiobutton(window, text='Третья кнопка', value = 3, variable=selected)
rad1.grid(column=2, row=5)  
rad2.grid(column=2, row=6)  
rad3.grid(column=2, row=7)

# Добавляем текстовую область ScrolledText
txt2 = scrolledtext.ScrolledText(window,width=40,height=10)
txt2.insert(INSERT, "Введите хоть что-нибудь")
txt2.grid(column=2, row=8) 
txt2.delete(1.0, END)   # Передаем координаты очистки

# Создаем всплывающие сообщения
messagebox.showinfo('Мой заголовок', 'Мой текст сообщения')
messagebox.showwarning('Мой заголовок предупреждения', 'Мой текст предупреждения')
messagebox.showerror('Мой заголовок ошибки', 'Мой текст ошибки')

# Создаем опросные окна
myAnswer = messagebox.askquestion("Заголовок вопроса", "Сам вопрос")    # yes no
myAnswer = messagebox.askyesno("Заголовок вопроса", "Сам вопрос")   #   True    False
myAnswer = messagebox.askyesnocancel("Заголовок вопроса", "Сам вопрос") # True  False   None
myAnswer = messagebox.askokcancel("Заголовок вопроса", "Сам вопрос")    # True  False
myAnswer = messagebox.askretrycancel("Заголовок вопроса", "Сам вопрос")     # True  False

# Создаем SpinBox
var = IntVar()
var.set(36)     # Установим значение по-умолчанию в 36
spin = Spinbox(window, from_=0, to=100, width=15, textvariable=var)   # SpinBox от 0 до 100
spin.grid(column=2, row=9)
spin2 = Spinbox(window, values=(3, 8, 11), width=15)   # SpinBox с тремя числами 3, 8, 11
spin2.grid(column=2, row=10)

# Добавляем ProgressBar
# Зададим его стиль и цвет
style = ttk.Style()
style.theme_use('default')
style.configure("black.Horizontal.TProgressbar", background='green')
# # Создаем прогресс-бар
bar = Progressbar(window, length=200, style='black.Horizontal.TProgressbar')
bar['value'] = 70   # По-умолчанию на 70%
bar.grid(column=2, row=11) 

# Добавляем поле загрузки файла 
# from tkinter import filedialog
file = filedialog.askopenfilename() # выбор одиного файла
# Укажем начальную директорию диалогового окна
from os import path
file = filedialog.askopenfilename(initialdir= path.dirname(__file__))
print(file) #   C:/Users/lavrov-sv/Documents/Default.rdp
files = filedialog.askopenfilenames()   # выбор сразу неколько файлов 
print(files)    #   ('C:/Users/lavrov-sv/Documents/Default.rdp', 'C:/Users/lavrov-sv/Documents/Шахматы.docx')
fileWithExt = filedialog.askopenfilename(filetypes = (("Text files","*.txt"),("all files","*.*")))  # файл по маске
print(fileWithExt)  #   D:/2/jurnal.txt
dir = filedialog.askdirectory() # Запрос выбора каталога
print(dir)  #   D:/2

window.mainloop()   # Отображаем все на экране
exit()